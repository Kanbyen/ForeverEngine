/*****************************************************************************************

Forever War - a NetHack-like FPS

Copyright (C) 2008 Thomas Sch√∂ps

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program;
if not, see <http://www.gnu.org/licenses/>.

*****************************************************************************************/

#ifndef _DIGISPE_ELEMENT_H_
#define _DIGISPE_ELEMENT_H_


// ||--- CONFIGURATION ---||

// Use this to enable caching of the measuring point radii at program start => faster voxel data generation, sligtly less accurate, longer startup time
#define DIGISPE_RADIUS_CACHE
#define INC_CACHE_SIZE (180)
#define DIR_CACHE_SIZE (360)

// ||---------------------||


#include <vector>
#include <list>
#include <OgreVector3.h>
#include <OgrePlane.h>

#include "levelElement.h"

class TiXmlElement;
class DigiSpeMeasuringPoint;

/// Base class for DigiSpe elements
class DigiSpeElement : public LevelElement
{
public:

	virtual void postprocess() = 0;
	virtual void autoImportSamples() = 0;
	virtual void postprocess2() = 0;
	virtual void saveOBJ(FILE* file, int& vIndex) {}
};

/// Extrusion (using multiple measuring points)
class DigiSpeExtrusion : public DigiSpeElement
{
public:

	struct Connection
	{
		DigiSpeMeasuringPoint* p1;
		DigiSpeMeasuringPoint* p2;
		Vector3 v1;
		Vector3 v1tov2;
		float squaredLength;
	};

	/// Measuring points are entered in this list
	typedef std::vector<DigiSpeMeasuringPoint*> ElementList;
	typedef ElementList::iterator ElementListItr;
	ElementList elements;
	ElementList auxElements;
	
	/// Connections are entered in this list
	typedef std::vector<Connection> ConnectionList;
	ConnectionList connections;

	/// Extrusions can be deactivated for debugging
	bool deactivated;
	
	/// Constructors & Destructor
	inline DigiSpeExtrusion() {};
	inline DigiSpeExtrusion(TiXmlElement* elem) {set(elem);};
	~DigiSpeExtrusion();
	
	/// Read extrusion description from file
	void set(TiXmlElement* elem);
	void getConnection(TiXmlElement* elem);
	
	/// Do post-processing (process getSample requests etc.)
	virtual void postprocess();
	virtual void autoImportSamples();
	virtual void postprocess2();
	
	virtual float apply(int x, int y, int z, float in);
};

/// Measuring Point
class DigiSpeMeasuringPoint : public DigiSpeElement
{
public:

	struct Triangle;

	/// Represents a sample point
	struct Sample
	{
		/// Direction from the sample center to the sample point (normalized)
		Vector3 dir;
		/// Length of the vector from the sample center to the sample point
		float len;
		/// This identifier should be unique!
		string name;
		/// Creates sharp or flat transitions to the neighbouring sample points. This is the inverse of the value specified in the cave file!
		float invspread;
		/// Flat surface or rounded surface?
		bool flat;
		/// If flat==true, this is the normal of the surface
		Vector3 normal;
		/// If flat==true, the constant in the plane equation
		float planeC;
		/// Sample this sample was connected to using connect="pair" or NULL. Used to implement the prevPair attribute and connections in GetSample requests
		Sample* pairPartner;
		/// Only valid if this sample was connected as pair (pairPartner != NULL). Points to the center point of the autogenerated connection
		Sample* connectionCenter;
		/// List of samples this sample was connected to using a line
		std::vector<Sample*> lineTo;
		/// List of triangles of which this sample is the a sample
		std::vector<Triangle*> triangleA;
	};
	/// Represents a linear connection between two sample points
	struct Line
	{
		Sample* s1;
		Sample* s2;

		Vector3 A;	// line starting point
		Vector3 B;	// line end point
		Vector3 AB;	// vector from start (A) to end (B)
		Vector3 N;	// normal of plane containing A, B and M (measuring point midpoint)
	};
	/// Represents a triangle consisting of three samples, three lines and the triangle area
	struct Triangle
	{
		Sample* a, *b, *c;
		Line* ab, *bc, *ca;
		Plane area;
	};

	/// List of sample points
	std::vector<Sample*> samples;

	/// List of lines
	std::vector<Line*> lines;
	
	/// List of triangles
	std::vector<Triangle*> triangles;


	/// This identifier should be unique!
	string name;

	/// Offset of this measuring point to the position specified in the cave file, sample position remain untouched
	Vector3 calcOffset;
	
	/// Similar to calcOffset, but changes dependent positions
	Vector3 pointOffset;
	
	/// If all lengths are off by a constant, this can be fixed by using lenAdjustment.
	/// For example, if all lengths are 18cm too long, use -0.18
	float lenAdjustment;

	/// Measuring points can be deactivated for debugging
	bool deactivated;

	/// Constructors & Destructor
	inline DigiSpeMeasuringPoint() {};
	inline DigiSpeMeasuringPoint(TiXmlElement* elem) {set(elem);};
	~DigiSpeMeasuringPoint();

	/// Read measuring point description from file
	void set(TiXmlElement* elem);
	/// Do post-processing
	virtual void postprocess();
	virtual void autoImportSamples();
	virtual void postprocess2();
	/// Save triangles to a file
	virtual void saveOBJ(FILE* file, int& vIndex);

	/// Read a sample point; returns the new sample
	Sample* getSamplePoint(TiXmlElement* elem, bool create = true);
	/// Read a line
	void getLine(TiXmlElement* elem);
	/// Read a triangle
	void getTriangle(TiXmlElement* elem);
	/// Read a cone
	void getCone(TiXmlElement* elem);
	/// Take a bunch of samples of another measuring point into this point
	void createGetSampleRequest(TiXmlElement* elem);

	/// Returns the sample with the specified name or NULL
	Sample* getSampleByName(const char* name, bool errorIfNotFound = true);

	/// Returns the coordinates (with digiSpe->scale!) of the given element or Vector3::ZERO if no coordinates are specified in the element
	Vector3 getCoords(TiXmlElement* elem, string prefix = "");

	/// Generates a sample point at the specified position
	Sample* autogenerateSample(Vector3 offset, const char* name);

	/// Creates a sample point
	void createSamplePoint(Sample* sample, bool autogenerated = false);
	/// Creates a line, returns the new sample if indent == true
	Sample* createLine(Sample* s1, Sample* s2, bool indent = false, bool addToLineTo = true, Line** out = NULL, bool triangulationTriangleLine = false);
	/// Create a triangle
	void createTriangle(Sample* a, Sample* b, Sample* c, bool addToTriangleA = true, bool triangulationTriangle = false);
	
	/// Gets a sample from another measuring point, returns the created copy of the sample
	Sample* importSample(DigiSpeMeasuringPoint* fromPoint, const char* name);

	float getRadiusForDirection(Vector3& direction);
	#ifdef DIGISPE_RADIUS_CACHE
	float getCachedRadiusForDirection(Vector3& direction);
	#endif
	virtual float apply(int x, int y, int z, float in);
	
	inline Vector3 getMidPoint() {return midPointF;};

protected:

	Vector3 midPointF;
	float maxradius;
	float minradius;

	/// Offset to be added to the sample ray start positions
	Vector3 sampleRayStartOffset;

	/// If true, the bounding box must be extended because the surface can extend the sample which is farthest away
	bool hasFlatSamplePoint;

	/// The previously read sample. Used to make the connect attribute work.
	Sample* prevSample;

	/// The previously read inc and dir values. Used to implement inc="prev" and dir="prev"
	float prevInc;
	float prevDir;
	
	/// Should this measuring point be triangulated?
	bool triangulate;
	
	/// Represents a triangulation triangle. area's normal is oriented in the way so inserting a point inside the hull into the plane equation will yield a positive number
	struct TriangulationTriangle
	{
		Sample* a, *b, *c;
		Plane area;
	};
	
	/// Represents a triangulation edge
	struct TriangulationEdge
	{
		Sample* a;
		Sample* b;
	};

	/// Measuring points are numbered so unique names for OGRE entities (of sample representations) can be provided
	int number;
	static int nextNumber;

	/// The &lt;Point&gt; tag
	TiXmlElement* elem;
	
	/// Struct to save line data for a second try (when samples from other measuring points have been imported)
	struct LineData
	{
		string from;
		string to;
	};
	/// Lines where a sample point was not found in the first try
	std::vector<LineData> brokenLineData;
	
	/// See LineData, this is the triangle equivalent
	struct TriangleData
	{
		string a;
		string b;
		string c;
	};
	/// See brokenLineData, this is the triangle equivalent
	std::vector<TriangleData> brokenTriangleData;
	
	/// Samples which are inside the Measuring Point and should be auto-imported. Every point must do this delayed, or it will result in chaos.
	std::vector< std::pair< DigiSpeMeasuringPoint*, std::string > > samplesToAutoImport;
	
	/// Helper function for triangle initialization: Adjust a triangle edge plane so that its normal faces in the direction of the third corner
	void triangleAdjustN(Line* line, Sample* s);
	
	/// Create triangulation from all samples
	void doTriangulate();
	void triangulationAddToStartingTetrahedron(Sample* a, Sample* b, Sample* c, Sample* innerDirectionSample, std::list< TriangulationTriangle >& result);
	void triangulationUpdate(Sample* s, std::list< TriangulationTriangle >& result);
	void triangulationAddToEdgeList(Sample* a, Sample* b, std::list< TriangulationEdge >& edgeList);

	#ifdef DIGISPE_RADIUS_CACHE
	float radiusCache[INC_CACHE_SIZE][DIR_CACHE_SIZE];
	void buildRadiusCache();
	#endif
};

#endif
