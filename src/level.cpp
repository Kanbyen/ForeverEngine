/*****************************************************************************************

Forever War - a NetHack-like FPS

Copyright (C) 2008 Thomas Sch√∂ps

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program;
if not, see <http://www.gnu.org/licenses/>.

*****************************************************************************************/

#include "precompiled.h"
#include "level.h"
#include "levelElement.h"
#include "levelTextureElement.h"
#include "blockConstants.h"
#include "noise.h"
#include "gameDataStorage.h"
#include "object.h"
#include "stateGame.h"
#include "volume.h"

#include "textureAtlas.h" // automatically generated by texatlas

Level* level;

const int texTop[NUM_LEVELS] = {TEXATLASNUMBER_SAND01, TEXATLASNUMBER_SAND01, TEXATLASNUMBER_GRASS01};
const int texSide[NUM_LEVELS] = {TEXATLASNUMBER_BUNKER_WALLS01, TEXATLASNUMBER_ROCK01, TEXATLASNUMBER_ROCK01};
const int texInner1[NUM_LEVELS] = {TEXATLASNUMBER_LARGE_BRICKS01, TEXATLASNUMBER_ROCK01, TEXATLASNUMBER_SAND01};
const int texInner2[NUM_LEVELS] = {TEXATLASNUMBER_LARGE_BRICKS01, TEXATLASNUMBER_ROCK01, TEXATLASNUMBER_SAND01};

int iRandMinMax(int imin, int imax)
{
	return (rand() % (imax - imin + 1)) + imin;
}
int getRandomDir(int allowedDirs)
{
	// Count allowed directions
	int numDirs = 0;
	for (int i = 0; i < 4; ++i)
		if (allowedDirs & (1 << i))
			numDirs++;

	// Select random direction to place a door
	int selectedDir = rand() % numDirs;
	// Find number of selected direction
	int dirCounter = 0;
	for (int i = 0; i < 4; ++i)
	{
		if (allowedDirs & (1 << i))
		{
			if (dirCounter == selectedDir)
				return i;

			dirCounter++;
		}
	}

	assert(!"Something strange happened. Memory corruption?!");
}

// ### Rock Field level ###
void Level::generate_RockField(ElementList& entrances, ElementList& exits, int startHeight, int endHeight)
{
	const int LEVEL_WIDTH = 90;
	const int BASEX = actLevel * LEVEL_LENGTH;
	const int BASEY = min(startHeight, endHeight);

	//const int NUM_ROCKS = 18;
	//const float ROCK_MINDIST = 25.0f;

	// Add ground; adjust height so that the first entrance is at ground height
	LevelElementFieldGround* ground = new LevelElementFieldGround(Point3(BASEX, BASEY - 1000, -LEVEL_WIDTH / 2), Point3(BASEX + LEVEL_LENGTH - 1, BASEY, LEVEL_WIDTH / 2));
	int height = ground->getHeightAboveGround(entrances[0]->bbMin);
	ground->set(Point3(ground->bbMin.x, ground->bbMin.y - height, ground->bbMin.z), Point3(ground->bbMax.x, ground->bbMax.y, ground->bbMax.z));
	elements[actLevel][0].push_back(ground);
	textures[actLevel].push_back(new LevelTextureElementAutotexCube(Point3(BASEX, BASEY - 1000 - height, -LEVEL_WIDTH / 2), Point3(BASEX + LEVEL_LENGTH - 1, BASEY+20 - height, LEVEL_WIDTH / 2), TEXATLASNUMBER_GRASS01, TEXATLASNUMBER_ROCK01, TEXATLASNUMBER_ROCK01, TEXATLASNUMBER_ROCK01));

	// TODO
	// Add rocks
	// First, create a list of blockers (where the rocks should NOT be)
	/*PositionList blockers;
	for (int i = 0; i < (int)entrances.size(); ++i)
	{
		blockers.push_back(entrances[i]->bbMin);
		blockers.push_back(entrances[i]->bbMax);
		// TODO: If it is a problem, we can also add the other corners of the entrances here (or a 3D grid of blocker points if the elements are really huge); this applies to the exits, too
	}
	for (int i = 0; i < (int)exits.size(); ++i)
	{
		blockers.push_back(exits[i]->bbMin);
		blockers.push_back(exits[i]->bbMax);
	}

	// Now create the rocks
	for (int i = 0; i < NUM_ROCKS; ++i)
	{
		Point3 pos = getRandomFreePosition(Point3(BASEX, BASEY - height - 5, -LEVEL_WIDTH / 2), Point3(BASEX + LEVEL_LENGTH - 1, BASEY - height + 5, LEVEL_WIDTH / 2), blockers, ROCK_MINDIST);
		float radius = Math::RangeRandom(6.0f, 12.0f);

		int height = ground->getHeightAboveGround(pos);
		pos.y -= height;

		elements[actLevel][1].push_back(new LevelElementSharpSphere(pos, radius));
		textures[actLevel].push_back(new LevelTextureElementSolidSphere(pos, radius+1, TEXATLASNUMBER_ROCK01));

		blockers.push_back(pos);
	}*/
}

// ### Level::DoorOrWindowSpace ###

bool Level::DoorOrWindowSpace::contains(Point3 p)
{
	return (p.x >= bbmin.x) && (p.x <= bbmax.x) && (p.z >= bbmin.z) && (p.z <= bbmax.z);
}
void Level::DoorOrWindowSpace::splitAt(Point3 p, int iDir)
{
	int adjustminsize = bbmax[iDir] - (p[iDir] + 1) + 1;
	int adjustmaxsize = p[iDir] - 1 - (bbmin[iDir]) + 1;

	if (adjustminsize < minimumWidth)
	{
		if (adjustmaxsize < minimumWidth)
		{
			enabled = false;
			// assert(!"A door space was split in a way that there is no space left for a door!");
		}
		else
			bbmax[iDir] = p[iDir] - 1;
	}
	else
	{
		if (adjustmaxsize < minimumWidth)
			bbmin[iDir] = p[iDir] + 1;
		else
		{
			// TODO: Should this decision depend on the size of the two parts? Can interesting results be obtained this way?
			if (iRandMinMax(0, 1) == 0)
				bbmin[iDir] = p[iDir] + 1;
			else
				bbmax[iDir] = p[iDir] - 1;
		}
	}
}
void Level::DoorOrWindowSpace::placeDoor(int width, int height, int layer)
{
	// TODO: Can interesting results be obtained by making the position calculation less random?

	if (!enabled)
		assert(!"Program wants to place a door, but DoorOrWindowSpace has been disabled!");

	int iDir;
	if (bbmin.x == bbmax.x)
		iDir = 2;
	else
		iDir = 0;

	int start = iRandMinMax(bbmin[iDir], bbmax[iDir] - width + 1);

	Point3 doorMin = bbmin;
	doorMin[iDir] = start;
	Point3 doorMax = bbmax;
	doorMax[iDir] = start + width - 1;
	doorMax.y = bbmin.y + height - 1;

	level->elements[level->actLevel][layer].push_back(new LevelElementInvSolidCube(doorMin, doorMax));
}
void Level::DoorOrWindowSpace::placeWindow(int width, int height, int heightAboveGround, int layer)
{
	if (!enabled)
		return;

	int iDir;
	if (bbmin.x == bbmax.x)
		iDir = 2;
	else
		iDir = 0;

	int start = iRandMinMax(bbmin[iDir] + 1, bbmax[iDir] - width + 1 - 1);

	Point3 wndMin = bbmin;
	wndMin[iDir] = start;
	wndMin.y += heightAboveGround;
	Point3 wndMax = bbmax;
	wndMax[iDir] = start + width - 1;
	wndMax.y = bbmin.y + height - 1 + heightAboveGround;

	//level->elements[level->actLevel][layer].push_back(new LevelElementInvSphere((wndMin + wndMax) / 2, width - 1));	// If you like sphere-shaped windows ...
	level->elements[level->actLevel][layer].push_back(new LevelElementInvSolidCube(wndMin, wndMax));
}

// ### Level::Building ###

Level::Building::Building()
{
	bmap = NULL;
	doorSpaces = NULL;
	numFloors = 1;
	actFloor = 0;
}
Level::Building::~Building()
{
	if (bmap)
	{
		// Clean up building map
		for (int floor = 0; floor < numFloors; ++floor)
		{
			for (int i = 0; i < bsizex; ++i)
				delete[] bmap[floor][i];
			delete[] bmap[floor];
		}
		delete[] bmap;
	}
	if (doorSpaces)
		delete[] doorSpaces;
}
void Level::Building::getDoorOrWindowSpaceInBuildingSide(int dir, int floor, bool window, int doorWidth, int windowWidth)
{
	const int VOXELS_PER_WINDOW = 8;

	DoorOrWindowSpace out;
	out.enabled = true;
	out.window = window;
	out.minimumWidth = window ? (windowWidth+2) : doorWidth;
	switch (1 << dir)
	{
	case BPLUSX:
		out.bbmin = Point3(roombbmax.x + 1, roombbmin.y, roombbmin.z);
		out.bbmax = Point3(roombbmax.x + 1, roombbmax.y, roombbmax.z);
	break;
	case BMINUSX:
		out.bbmin = Point3(roombbmin.x - 1, roombbmin.y, roombbmin.z);
		out.bbmax = Point3(roombbmin.x - 1, roombbmax.y, roombbmax.z);
	break;
	case BPLUSZ:
		out.bbmin = Point3(roombbmin.x, roombbmin.y, roombbmax.z + 1);
		out.bbmax = Point3(roombbmax.x, roombbmax.y, roombbmax.z + 1);
	break;
	case BMINUSZ:
		out.bbmin = Point3(roombbmin.x, roombbmin.y, roombbmin.z - 1);
		out.bbmax = Point3(roombbmax.x, roombbmax.y, roombbmin.z - 1);
	break;
	}

	// Try to create multiple windows in long building sides
	if (window)
	{
		Point3 bbmin = out.bbmin;
		Point3 bbmax = out.bbmax;

		int iDir;
		if (out.bbmin.x == out.bbmax.x)
			iDir = 2;
		else
			iDir = 0;
		int len = bbmax[iDir] - bbmin[iDir] + 1;

		if (len >= 2 * VOXELS_PER_WINDOW)
		{
			int count = len / VOXELS_PER_WINDOW;
			int singleLen = len / count;
			for (int i = 0; i < count; ++i)
			{
				out.bbmin = bbmin;
				out.bbmin[iDir] = bbmin[iDir] + singleLen * i;
				out.bbmax = bbmax;
				out.bbmax[iDir] = out.bbmin[iDir] + singleLen - 1;

				doorSpaces[floor].push_back(out);
			}

			return;
		}
	}

	doorSpaces[floor].push_back(out);
}
void Level::Building::generateBuildingBase(int doorDirs, int texFloor, int doorWidth, int windowWidth)
{
	doorSpaces = new DoorOrWindowSpaceList[numFloors];
	roombbmin = Point3(bbmin.x + 1, bbmin.y + 0, bbmin.z + 1);
	roombbmax = Point3(bbmax.x - 1, bbmax.y - 1, bbmax.z - 1);

	if (numFloors == 1)
		floorHeight = bbmax.y - bbmin.y + 1 - 1;

	// Add a hollow block for every floor as starting point
	level->elements[level->actLevel][0].push_back(new LevelElementSolidCube(bbmin, bbmax));				// solid block
	level->textures[level->actLevel].push_back(new LevelTextureElementSolidCube(bbmin, bbmax, TEXATLASNUMBER_BUNKER_WALLS01));					// Wall texture
	level->textures[level->actLevel].push_back(new LevelTextureElementSolidCube(Point3(bbmin.x, bbmax.y-1, bbmin.z), Point3(bbmax.x, bbmax.y+1, bbmax.z),
																				TEXATLASNUMBER_ASPHALT01));										// Roof texture
	for (int floor = 0; floor < numFloors; ++floor)
	{
		setActFloor(floor);
		level->elements[level->actLevel][0].push_back(new LevelElementInvSolidCube(roombbmin, roombbmax));	// carve out
		level->textures[level->actLevel].push_back(new LevelTextureElementSolidCube(Point3(roombbmin.x, roombbmin.y-1, roombbmin.z),
																					Point3(roombbmax.x, roombbmin.y+1, roombbmax.z), texFloor));	// Floor texture

		if (floor > 0)
		{
			// Add windows
			for (int dir = 0; dir < 4; ++dir)
				if ((1 << dir) & doorDirs)
					getDoorOrWindowSpaceInBuildingSide(dir, floor, true, doorWidth, windowWidth);
		}
	}
	setActFloor(0);

	// Determine "door space" of the entrance door
	int doorDir = getRandomDir(doorDirs);
	getDoorOrWindowSpaceInBuildingSide(doorDir, 0, false, doorWidth, windowWidth);

	// Add spaces for windows of floor 0
	for (int dir = 0; dir < 4; ++dir)
	{
		if ((dir != doorDir) && ((1 << dir) & doorDirs))
			getDoorOrWindowSpaceInBuildingSide(dir, 0, true, doorWidth, windowWidth);
	}
}
void Level::Building::calculateSplitSizes(int splitFreeSpaceNeeded)
{
	bsizex = bbmax.x - bbmin.x + 1;
	bsizez = bbmax.z - bbmin.z + 1;

	posXMax = bsizex - 1 - splitFreeSpaceNeeded - 1;
	posXMin = splitFreeSpaceNeeded + 1;
	int freePositionsX = posXMax - posXMin + 1;

	posZMax = bsizez - 1 - splitFreeSpaceNeeded - 1;
	posZMin = splitFreeSpaceNeeded + 1;
	int freePositionsZ = posZMax - posZMin + 1;

	zsplitPossible = (freePositionsX >= 1);	// Attention: reversal of x/z!
	xsplitPossible = (freePositionsZ >= 1);
}
void Level::Building::createBMap()
{
	bmap = new char**[numFloors];

	for (int floor = 0; floor < numFloors; ++floor)
	{
		bmap[floor] = new char*[bsizex];
		for (int i = 0; i < bsizex; ++i)
		{
			bmap[floor][i] = new char[bsizez];
			if (i == 0 || i == bsizex - 1)
				memset(bmap[floor][i], 1, bsizez);
			else
			{
				bmap[floor][i][0] = 1;
				bmap[floor][i][bsizez - 1] = 1;
				memset(&bmap[floor][i][1], 0, bsizez - 2);
			}
		}
	}
}
void Level::Building::createDoorsAndWindows(int doorWidth, int doorHeight, int windowWidth, int windowHeight, int windowHeightAboveGround)
{
	// Place real doors in the door spaces
	for (int floor = 0; floor < numFloors; ++floor)
	{
		for (int i = 0; i < (int)doorSpaces[floor].size(); ++i)
		{
			if (doorSpaces[floor][i].window)
				doorSpaces[floor][i].placeWindow(windowWidth, windowHeight, windowHeightAboveGround, 1);
			else
				doorSpaces[floor][i].placeDoor(doorWidth, doorHeight, 0);
		}
	}
}
int Level::Building::getRoomVolume()
{
	Point3 innerDimensions = (roombbmax - roombbmin) + Point3(1, 1, 1);
	return innerDimensions.x * innerDimensions.y * innerDimensions.z;
}
void Level::Building::splitUp(int numSplitTries, int splitFreeSpaceNeeded, int doorWidth, bool carveCornerAllowed, int carveOutPercentage)
{
	/*
	 * SPLIT TYPES:
	 *
	 * 0: straight
	 * 1: corner
	 */

	Point3 roomBase = roombbmin - Point3(1, 0, 1);

	for (int s = 0; s < numSplitTries; ++s)
	{
		int splitType;
		// Determine the type of the split
		if (xsplitPossible && zsplitPossible)
		{
			splitType = iRandMinMax(0, 1);
		}
		else
			splitType = 0;

		// Determine the direction(s) of the split
		// First direction
		Point3 splitDir = Point3(0, 0, 0);
		int iSplitDir;
		if (!xsplitPossible)
			iSplitDir = 2;
		else if (!zsplitPossible)
			iSplitDir = 0;
		else
		{
			if (iRandMinMax(0, 1) == 0)
				iSplitDir = 0;
			else
				iSplitDir = 2;
		}
		splitDir[iSplitDir] = (iRandMinMax(0, 1) == 0) ? 1 : -1;

		// Second direction
		Point3 splitDir2 = Point3(0, 0, 0);
		int iSplitDir2 = -1;
		if (splitType == 0)
		{
			splitDir2 = -splitDir;
			iSplitDir2 = iSplitDir;
		}
		else if (splitType == 1)
		{
			iSplitDir2 = 2 - iSplitDir;
			splitDir2[iSplitDir2] = (iRandMinMax(0, 1) == 0) ? 1 : -1;
		}

		// Randomly determine split position
		int splitx;
		int splitz;
		int checkx;
		int checkz;
		int splitFreeSpaceNeededSide;
		if (splitType == 0)
			splitFreeSpaceNeededSide = doorWidth / 2;
		else
			splitFreeSpaceNeededSide = splitFreeSpaceNeeded;
		if (iSplitDir == 0)
		{
			splitx = iRandMinMax(splitFreeSpaceNeededSide + 1, bsizex - 1 - splitFreeSpaceNeededSide - 1);
			checkx = splitFreeSpaceNeededSide;
			splitz = iRandMinMax(posZMin, posZMax);
			checkz = splitFreeSpaceNeeded;
		}
		else
		{
			splitx = iRandMinMax(posXMin, posXMax);
			checkx = splitFreeSpaceNeeded;
			splitz = iRandMinMax(splitFreeSpaceNeededSide + 1, bsizez - 1 - splitFreeSpaceNeededSide - 1);
			checkz = splitFreeSpaceNeededSide;
		}

		// Check if the position is free
		bool bContinue = false;
		for (int x = splitx - checkx; x <= splitx + checkx; ++x)
		{
			for (int z = splitz - checkz; z <= splitz + checkz; ++z)
			{
				if (bmap[actFloor][x][z] != 0)
				{
					bContinue = true;
					break;
				}
			}
			if (bContinue)
				break;
		}
		if (bContinue)
			continue;

		// Step into direction(s) and check if they are free
		// Step into first direction
		Point3 actPos = Point3(splitx, 0, splitz);
		Point3 splitDirSide = Point3(0, 0, 0);
		splitDirSide[2 - iSplitDir] = 1;
		while (bmap[actFloor][actPos.x][actPos.z] == 0)
		{
			for (int i = -splitFreeSpaceNeeded; i <= splitFreeSpaceNeeded; ++i)
			{
				if (bmap[actFloor][actPos.x + i * splitDirSide.x][actPos.z + i * splitDirSide.z] != 0)
				{
					bContinue = true;
					break;
				}
			}
			if (bContinue)
				break;
			actPos += splitDir;
		}
		if (bContinue)
			continue;

		// Step into second direction
		actPos = Point3(splitx, 0, splitz);
		Point3 splitDirSide2 = Point3(0, 0, 0);
		splitDirSide2[2 - iSplitDir2] = 1;
		while (bmap[actFloor][actPos.x][actPos.z] == 0)
		{
			for (int i = -splitFreeSpaceNeeded; i <= splitFreeSpaceNeeded; ++i)
			{
				if (bmap[actFloor][actPos.x + i * splitDirSide2.x][actPos.z + i * splitDirSide2.z] != 0)
				{
					bContinue = true;
					break;
				}
			}
			if (bContinue)
				break;
			actPos += splitDir2;
		}
		if (bContinue)
			continue;

		// Enter the split in the map and split up door spaces in the walls which are touched
		// Step into first direction
		actPos = Point3(splitx, 0, splitz);
		do
		{
			bmap[actFloor][actPos.x][actPos.z] = 1;
			actPos += splitDir;
		} while (bmap[actFloor][actPos.x][actPos.z] == 0);
		// We hit a wall, check if a door space is there -> split it up
		for (int i = 0; i < (int)doorSpaces[actFloor].size(); ++i)
		{
			DoorOrWindowSpace& doorSpace = doorSpaces[actFloor][i];
			if (doorSpace.contains(roomBase + actPos))
				doorSpace.splitAt(roomBase + actPos, 2 - iSplitDir);
		}
		Point3 wallEnd1 = Point3(actPos.x, 0, actPos.z) - splitDir;

		// Step into second direction
		actPos = Point3(splitx, 0, splitz);
		do
		{
			bmap[actFloor][actPos.x][actPos.z] = 1;
			actPos += splitDir2;
		} while (bmap[actFloor][actPos.x][actPos.z] == 0);
		// We hit a wall, check if a door space is there -> split it up
		for (int i = 0; i < (int)doorSpaces[actFloor].size(); ++i)
		{
			DoorOrWindowSpace& doorSpace = doorSpaces[actFloor][i];
			if (doorSpace.contains(roomBase + actPos))
				doorSpace.splitAt(roomBase + actPos, 2 - iSplitDir2);
		}
		Point3 wallEnd2 = Point3(actPos.x, 0, actPos.z) - splitDir2;

		if (splitType == 0)
		{
			// Determine wall bounding box, add wall geometry
			Point3 wallbbmin = Point3(min(wallEnd1.x, wallEnd2.x), 0,                        min(wallEnd1.z, wallEnd2.z));
			Point3 wallbbmax = Point3(max(wallEnd1.x, wallEnd2.x), roombbmax.y - roomBase.y, max(wallEnd1.z, wallEnd2.z));
			wallbbmin += roomBase;
			wallbbmax += roomBase;

			level->elements[level->actLevel][0].push_back(new LevelElementSolidCube(wallbbmin, wallbbmax));

			// Add new door space
			DoorOrWindowSpace newInnerDoor;
			newInnerDoor.enabled = true;
			newInnerDoor.window = false;
			newInnerDoor.minimumWidth = doorWidth;
			newInnerDoor.bbmin = wallbbmin;
			newInnerDoor.bbmax = wallbbmax;
			doorSpaces[actFloor].push_back(newInnerDoor);
		}
		else if (splitType == 1)
		{
			// Check if the corner should be carved out: do this randomly if it is allowed
			bool carveOut = (carveCornerAllowed && iRandMinMax(0, 100) < carveOutPercentage);
			int remainingFloors = carveOut ? (numFloors - actFloor) : 1;

			// Determine first wall bounding box, add wall geometry
			Point3 wallbbmin = Point3(min(wallEnd1.x, splitx), 0,                                                min(wallEnd1.z, splitz));
			Point3 wallbbmax = Point3(max(wallEnd1.x, splitx), (roombbmax.y - roomBase.y + 2) * remainingFloors - 1, max(wallEnd1.z, splitz));
			wallbbmin += roomBase;
			wallbbmax += roomBase;

			level->elements[level->actLevel][0].push_back(new LevelElementSolidCube(wallbbmin, wallbbmax));

			wallbbmin = Point3(min(wallEnd1.x, splitx + splitDir.x), 0,                        min(wallEnd1.z, splitz + splitDir.z));
			wallbbmax = Point3(max(wallEnd1.x, splitx + splitDir.x), roombbmax.y - roomBase.y, max(wallEnd1.z, splitz + splitDir.z));
			wallbbmin += roomBase;
			wallbbmax += roomBase;

			// Determine second wall bounding box, add wall geometry
			Point3 wall2bbmin = Point3(min(wallEnd2.x, splitx + splitDir2.x), 0,                                                min(wallEnd2.z, splitz + splitDir2.z));
			Point3 wall2bbmax = Point3(max(wallEnd2.x, splitx + splitDir2.x), (roombbmax.y - roomBase.y + 2) * remainingFloors - 1, max(wallEnd2.z, splitz + splitDir2.z));
			wall2bbmin += roomBase;
			wall2bbmax += roomBase;

			level->elements[level->actLevel][0].push_back(new LevelElementSolidCube(wall2bbmin, wall2bbmax));

			// Add new door space randomly in one or two of the walls
			bool doorInSecondWall = false;
			if (iRandMinMax(0, 1) == 0)
			{
				// Add door in first wall
				DoorOrWindowSpace newInnerDoor;
				newInnerDoor.enabled = true;
				newInnerDoor.window = false;
				newInnerDoor.minimumWidth = doorWidth;
				newInnerDoor.bbmin = wallbbmin;
				newInnerDoor.bbmax = wallbbmax;
				doorSpaces[actFloor].push_back(newInnerDoor);

				// Also in second wall?
				if (iRandMinMax(0, 1) == 0)
					doorInSecondWall = true;
			}
			else
				doorInSecondWall = true;

			if (doorInSecondWall)
			{
				// Add door in second wall
				DoorOrWindowSpace newInnerDoor;
				newInnerDoor.enabled = true;
				newInnerDoor.window = false;
				newInnerDoor.minimumWidth = doorWidth;
				newInnerDoor.bbmin = wall2bbmin;
				newInnerDoor.bbmax = wall2bbmax;
				doorSpaces[actFloor].push_back(newInnerDoor);
			}

			// Randomly carve out the whole corner if allowed; do this for all higher floors, too
			
			if (carveOut)
			{
				int x1 = splitx + splitDir.x + splitDir2.x;
				int z1 = splitz + splitDir.z + splitDir2.z;
				int x2, z2;
				if (iSplitDir == 0)
				{
					x2 = wallEnd1.x;
					z2 = wallEnd2.z;
				}
				else	// (iSplitDir == 2)
				{
					x2 = wallEnd2.x;
					z2 = wallEnd1.z;
				}
				if (x2 == 1)	x2 = 0;
				if (z2 == 1)	z2 = 0;
				if (x2 == bsizex-2)	x2 = bsizex-1;
				if (z2 == bsizez-2)	z2 = bsizez-1;
				Point3 cornerbbmin = Point3(min(x1, x2), 0,                                                min(z1, z2));
				Point3 cornerbbmax = Point3(max(x1, x2), (roombbmax.y - roomBase.y + 2) * remainingFloors - 1, max(z1, z2));

				// Enter free space in map
				for (int floor = actFloor; floor < numFloors; ++floor)
					for (int x = cornerbbmin.x; x <= cornerbbmax.x; ++x)
						for (int z = cornerbbmin.z; z <= cornerbbmax.z; ++z)
							bmap[floor][x][z] = 2;

				// Carve out free space
				cornerbbmin += roomBase;
				cornerbbmax += roomBase;
				level->elements[level->actLevel][1].push_back(new LevelElementInvSolidCube(cornerbbmin, cornerbbmax));

				// TODO: different floor texture for free space (if floor 0)?
			}
		}
	}
}
void Level::Building::calcNumFloorsAndAdjustBB(int floorHeight)
{
	this->floorHeight = floorHeight;
	int actHeight = bbmax.y - bbmin.y + 1;
	numFloors = actHeight / (floorHeight+1);
	bbmax.y = bbmin.y + numFloors * (floorHeight+1) - 1;
}
void Level::Building::setActFloor(int floor)
{
	this->actFloor = floor;
	roombbmin = Point3(bbmin.x + 1, bbmin.y + floor * (floorHeight+1), bbmin.z + 1);
	roombbmax = Point3(bbmax.x - 1, bbmin.y + (floor+1) * (floorHeight+1) - 2, bbmax.z - 1);
}

void Level::generateHouse(Building& b, int doorDirs, int texFloor)
{
	const int DOOR_WIDTH = 4;
	const int DOOR_HEIGHT = 6;
	const int WINDOW_WIDTH = 3;
	const int WINDOW_HEIGHT = 3;
	const int WINDOW_HEIGHT_ABOVE_GROUND = 2;
	const int SPLIT_POINT_FREE_SPACE_NEEDED = 4;
	const int NUM_SPLIT_TRIES = 6;
	const bool CARVE_OUT_ALLOWED = true;
	const int CARVE_OUT_PERCENTAGE = 80;
	const int MIN_SUBDIVIDE_VOLUME = 11*11*11;

	b.generateBuildingBase(doorDirs, texFloor, DOOR_WIDTH, WINDOW_WIDTH);
	b.calculateSplitSizes(SPLIT_POINT_FREE_SPACE_NEEDED);

	// If the house is big enough, split it up into smaller rooms
	if ((b.getRoomVolume() >= MIN_SUBDIVIDE_VOLUME) && (b.xsplitPossible || b.zsplitPossible))
	{
		b.createBMap();

		b.splitUp(NUM_SPLIT_TRIES, SPLIT_POINT_FREE_SPACE_NEEDED, DOOR_WIDTH, CARVE_OUT_ALLOWED, CARVE_OUT_PERCENTAGE);
	}

	b.createDoorsAndWindows(DOOR_WIDTH, DOOR_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_HEIGHT_ABOVE_GROUND);
}
void Level::generateSkyscraper(Building& b, int doorDirs, int texFloor)
{
	const int DOOR_WIDTH = 4;
	const int DOOR_HEIGHT = 6;
	const int WINDOW_WIDTH = 3;
	const int WINDOW_HEIGHT = 3;
	const int WINDOW_HEIGHT_ABOVE_GROUND = 2;
	const int SPLIT_POINT_FREE_SPACE_NEEDED = 7;
	const int NUM_SPLIT_TRIES = 15;
	const bool CARVE_OUT_ALLOWED = true;
	const int CARVE_OUT_PERCENTAGE = 60;

	const int FLOOR_HEIGHT = 8;	// -> building height: numFloors * (FLOOR_HEIGHT + 1)

	b.calcNumFloorsAndAdjustBB(FLOOR_HEIGHT);
	b.generateBuildingBase(doorDirs, texFloor, DOOR_WIDTH, WINDOW_WIDTH);
	b.calculateSplitSizes(SPLIT_POINT_FREE_SPACE_NEEDED);

	if (b.xsplitPossible || b.zsplitPossible)
	{
		b.createBMap();

		for (int floor = 0; floor < b.numFloors; ++floor)
		{
			b.setActFloor(floor);
			b.splitUp(NUM_SPLIT_TRIES, SPLIT_POINT_FREE_SPACE_NEEDED, DOOR_WIDTH, CARVE_OUT_ALLOWED, CARVE_OUT_PERCENTAGE);
		}
	}

	b.createDoorsAndWindows(DOOR_WIDTH, DOOR_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_HEIGHT_ABOVE_GROUND);
}

// ### City level ###
void Level::generate_City(ElementList& entrances, ElementList& exits, int startHeight, int endHeight)
{
	const int CELL_SIZE = 10;
	const int LEVEL_WIDTH = 9 * CELL_SIZE;
	const int MAX_NUM_BUILDINGS = 40;
	const int MAX_BUILDING_LEN = 3;
	const int MIN_BUILDING_HEIGHT = 8;
	const int MAX_BUILDING_HEIGHT_ADDITION = 3*8;

	const int BASEZ = -LEVEL_WIDTH / 2;
	const int BASEX = actLevel * LEVEL_LENGTH;
	const int BASEY = min(startHeight, endHeight);

	const int MAXZ = LEVEL_WIDTH / CELL_SIZE;
	const int MAXX = LEVEL_LENGTH / CELL_SIZE;
	int field[MAXX][MAXZ];	// Values: 0 currently free, 1 must remain free, 10 covered by building

	BuildingList blist;
	Building* newb;

	// Add ground
	elements[actLevel][0].push_back(new LevelElementCube(Point3(BASEX, BASEY - 1000, -LEVEL_WIDTH / 2), Point3(BASEX + LEVEL_LENGTH - 1, BASEY, LEVEL_WIDTH / 2)));
	textures[actLevel].push_back(new LevelTextureElementAutotexCube(Point3(BASEX, BASEY - 1000, -LEVEL_WIDTH / 2), Point3(BASEX + LEVEL_LENGTH - 1, BASEY, LEVEL_WIDTH / 2), TEXATLASNUMBER_SAND01, TEXATLASNUMBER_ROCK01, TEXATLASNUMBER_ASPHALT01, TEXATLASNUMBER_ROCK01));

	// Fill field with "free"
	for (int x = 0; x < MAXX; ++x)
		for (int z = 0; z < MAXZ; ++z)
			field[x][z] = 0;

	// Mark entrance and exit field as "must remain free"
	for (int i = 0; i < (int)entrances.size(); ++i)
	{
		int x1 = entrances[i]->bbMin.x / level->scale ;
		x1 = max(0, min(MAXX - 1, x1 / CELL_SIZE));
		int x2 = entrances[i]->bbMax.x / level->scale;
		x2 = max(0, min(MAXX - 1, x2 / CELL_SIZE));
		int z1 = entrances[i]->bbMin.z / level->scale + LEVEL_WIDTH / 2;
		z1 = max(0, min(MAXZ - 1, z1 / CELL_SIZE));
		int z2 = entrances[i]->bbMax.z / level->scale + LEVEL_WIDTH / 2;
		z2 = max(0, min(MAXZ - 1, z2 / CELL_SIZE));

		for (int x = x1; x <= x2; ++x)
			for (int z = z1; z <= z2; ++z)
				field[x][z] = 1;
	}
	for (int i = 0; i < (int)exits.size(); ++i)
	{
		int x1 = exits[i]->bbMin.x / level->scale ;
		x1 = max(0, min(MAXX - 1, x1 / CELL_SIZE));
		int x2 = exits[i]->bbMax.x / level->scale;
		x2 = max(0, min(MAXX - 1, x2 / CELL_SIZE));
		int z1 = exits[i]->bbMin.z / level->scale + LEVEL_WIDTH / 2;
		z1 = max(0, min(MAXZ - 1, z1 / CELL_SIZE));
		int z2 = exits[i]->bbMax.z / level->scale + LEVEL_WIDTH / 2;
		z2 = max(0, min(MAXZ - 1, z2 / CELL_SIZE));

		for (int x = x1; x <= x2; ++x)
			for (int z = z1; z <= z2; ++z)
				field[x][z] = 1;
	}

	// Randomly scatter buildings
	for (int i = 0; i < MAX_NUM_BUILDINGS; ++i)
	{
		// The position where the building will finally be placed
		int posx;
		int posz;
		// The dimensions of the building
		int sizex = (rand() % MAX_BUILDING_LEN) + 1;
		int sizez = (rand() % MAX_BUILDING_LEN) + 1;

		int maxheight = (min(sizex, sizez) - 1) * 2 * 8;
		int sizey = (min(maxheight, rand() % MAX_BUILDING_HEIGHT_ADDITION)) + MIN_BUILDING_HEIGHT;
		

		// Find a free position
		bool ok = false;
		for (int x = 0; x <= MAXX - sizex; ++x)
		{
			for (int z = 0; z <= MAXZ - sizez; ++z)
			{
				// Check if this position is free ...
				// How far do we have to check?
				bool noFreeSpaceInXDir = false;	// buildings to the very left or right may have directly adjacent buildings

				int startz = z;
				int maxdz = sizez - 1;
				if (z > 0)
				{
					startz--;
					maxdz++;
				}
				else
					noFreeSpaceInXDir = true;
				if (z < MAXZ - sizez)
					maxdz++;
				else
					noFreeSpaceInXDir = true;

				int startx = x;

				int maxdx = sizex - 1;
				if (!noFreeSpaceInXDir)
				{
					if (x > 0)
					{
						startx--;
						maxdx++;
					}
					if (x < MAXX - sizex)
						maxdx++;
				}

				// Check the building area for all obstacles
				for (int dx = 0; dx <= sizex - 1; ++dx)
					for (int dz = 0; dz <= sizez - 1; ++dz)
						if (field[x+dx][z+dz] != 0)
							goto obstacle;

				// Check the far area for building obstacles only so there are no adjacent buildings, but buildings can be adjacent to "must remain free" areas
				for (int dx = 0; dx <= maxdx; ++dx)
					for (int dz = 0; dz <= maxdz; ++dz)
						if (field[startx+dx][startz+dz] == 10)
							goto obstacle;

				// Position is free!
				ok = true;
				posx = x;
				posz = z;
				goto found;

obstacle:;
			}
		}

found:;

		if (!ok)
			continue;	// Don't place this building as there is no free space for it

		newb = new Building();

		// Place the building
		for (int dx = 0; dx < sizex; ++dx)
			for (int dz = 0; dz < sizez; ++dz)
				field[posx+dx][posz+dz] = 10;

		// Calculate bounding box
		newb->bbmin = Point3(BASEX + posx*CELL_SIZE, BASEY + 0, BASEZ + posz*CELL_SIZE);
		newb->bbmax = Point3(BASEX + (posx+sizex)*CELL_SIZE-1, BASEY + 1 + sizey, BASEZ + (posz+sizez)*CELL_SIZE-1);
		blist.push_back(newb);

		// Check which door / window directions are possible
		int doorDirs = 0;
		if (posx > 0)
		{
			if (posz > 0 && posz + sizez - 1 < MAXZ - 1)
				doorDirs |= BMINUSX;
		}
		if (posz > 0)						doorDirs |= BMINUSZ;
		if (posx + sizex - 1 < MAXX - 1)
		{
			if (posz > 0 && posz + sizez - 1 < MAXZ - 1)
				doorDirs |= BPLUSX;
		}
		if (posz + sizez - 1 < MAXZ - 1)
			doorDirs |= BPLUSZ;
		assert(doorDirs != 0);

		// Generate a building
		if (newb->bbmax.y - newb->bbmin.y + 1 >= 18)
		{
			newb->bbmax.y += 30;	// make skyscrapers really high!
			generateSkyscraper(*newb, doorDirs, TEXATLASNUMBER_ASPHALT01);
		}
		else
			generateHouse(*newb, doorDirs, TEXATLASNUMBER_SAND01);
	}

	// Generate objects
	for (int x = 0; x < MAXX; ++x)
	{
		for (int z = 0; z < MAXZ; ++z)
		{
			if (field[x][z] == 0)
			{
				generateObj_OpenStreet(ObjectSpawnAreaCube(Point3(BASEX + x*CELL_SIZE, BASEY + 1, BASEZ + z*CELL_SIZE),
														   Point3(BASEX + (x+1)*CELL_SIZE-1, BASEY + 1 + 10, BASEZ + (z+1)*CELL_SIZE-1)));
			}
		}	
	}
	// TODO: Generate objects in buildings

	// Clean up
	for (int i = 0; i < (int)blist.size(); ++i)
		delete blist[i];
}

// ### "Cave" - level ###
void Level::generate_Cave(ElementList& entrances, ElementList& exits, int startHeight, int endHeight)
{
	const int NUM_CAVE_SECTORS = 3;	// in the range [0; +inf[
	float sectorStep = LEVEL_LENGTH / (NUM_CAVE_SECTORS + 1);

	ElementList* tempList[2];
	ConnectionList conList;

	// Create base texturing
	textures[actLevel].push_back(new LevelTextureElementAutotexCube(
		Point3(actLevel * LEVEL_LENGTH, -999999, -999999),
		Point3((actLevel+1) * LEVEL_LENGTH - 1, 999999, 999999),
		texTop[actLevel], texSide[actLevel], texInner1[actLevel], texInner2[actLevel]));

	// Create sections and starting connections
	elements[actLevel][0] = entrances;
	tempList[0] = &entrances;
	for (int i = 1; i <= NUM_CAVE_SECTORS + 1; i++)
	{
		if (i == NUM_CAVE_SECTORS + 1)
			tempList[1] = &exits;
		else
		{
			// Fill tempList[1]
			tempList[1] = new ElementList();
			createRandomSpheresAt(Vector3(actLevel * LEVEL_LENGTH + i * sectorStep - sectorStep / 4, startHeight + (endHeight - startHeight) * (float)i / (NUM_CAVE_SECTORS + 2) - 7, -45),
								  Vector3(actLevel * LEVEL_LENGTH + i * sectorStep + sectorStep / 4, startHeight + (endHeight - startHeight) * (float)(i+1) / (NUM_CAVE_SECTORS + 2) + 7, 45),
								  8, 14,
								  24, (int)Math::RangeRandom(2, 4), (actLevel % 2) == 1, *tempList[1], 0.9f);

			// Create objects at tempList[1] positions
			for (int l1 = 0; l1 < (int)tempList[1]->size(); l1++)
			{
				Point3 midPoint = (*tempList[1])[l1]->midPoint;
				if ((actLevel % 2) == 0)
					midPoint += Point3(0, ((LevelElementSphere*)((*tempList[1])[l1]))->radius, 0);
				generateObj_SmallRoom(ObjectSpawnAreaCube(midPoint - Point3(3, 3, 3), midPoint + Point3(3, 3, 3)));
			}

			// Connect tempList[1]
			// TODO: connect or not?
		}

		// Create connections from every tempList[0] to every tempList[1]
		for (int l0 = 0; l0 < (int)tempList[0]->size(); l0++)
			for (int l1 = 0; l1 < (int)tempList[1]->size(); l1++)
				conList.push_back(new Connection((*tempList[0])[l0], (*tempList[1])[l1]));

		// Add tempList[1] to the output
		for (int k = 0; k < (int)tempList[1]->size(); k++)
			elements[actLevel][0].push_back((*tempList[1])[k]);

		// Prepare for the next sector
		if (i != 1)
			delete tempList[0];
		tempList[0] = tempList[1];
	}

	// Resolve connections
	while (conList.size())
	{
		Connection* con = conList[conList.size() - 1];
		conList.pop_back();

		if (con->lengthSq >= 9 * 9)
		{
			LevelElement* newElement;
			if ((actLevel % 2) == 1)
				newElement = new LevelElementInvSphere(Point3(con->midPoint), Math::RangeRandom(4, 7));
			else
				newElement = new LevelElementSphere(Point3(con->midPoint), Math::RangeRandom(4, 7));
			elements[actLevel][0].push_back(newElement);

			Connection* con1 = new Connection(con->start, con->midPoint);
			conList.push_back(con1);
			Connection* con2 = new Connection(con->midPoint, con->end);
			conList.push_back(con2);

			// Add some randomly scattered spheres
			if (Math::RangeRandom(0, 1) <= 0.2f)
			{
				Vector3 pos = con->midPoint + Vector3(Math::RangeRandom(-4, 4), Math::RangeRandom(-1, 1), Math::RangeRandom(-5, 5));
				if ((actLevel % 2) == 1)
					newElement = new LevelElementInvSphere(Point3(pos), Math::RangeRandom(3, 6));
				else
					newElement = new LevelElementSphere(Point3(pos), Math::RangeRandom(3, 6));
				elements[actLevel][0].push_back(newElement);
			}
		}

		delete con;
	}
}

void Level::generateObj_StartingEquipment(Point3 midpoint)
{
	Vector3 vMidpoint = pointToVector(midpoint);

	LevelObject obj;
	obj.type = "pistol";
	obj.pos = vMidpoint + Vector3(0.0f, 0.0f, 2.0f);
	objects.push_back(obj);

	obj.type = "grenade";
	obj.pos = vMidpoint + Vector3(0.0f, 0.0f, -2.0f);
	objects.push_back(obj);

	obj.type = "geometry gun";
	obj.pos = vMidpoint + Vector3(0.0f, 0.0f, 0.0f);
	objects.push_back(obj);
}
void Level::generateObj_SmallRoom(const ObjectSpawnArea& area)
{
	LevelObject obj;

	// TODO!
	// For now, just create 2 guard spheres ...
	/*
	for (int i = 0; i < 2; ++i)
	{
		obj.type = "guard sphere";
		obj.pos = area.generateAirPosition();
		objects.push_back(obj);
	}
	*/
}
void Level::generateObj_OpenStreet(const ObjectSpawnArea& area)
{
	LevelObject obj;
	const char* genList1[3] = {"box 1", "box 2", "explosive barrel 1"};
	
	// 33% chance to generate objects
	if (rand() % 3 != 0)
		return;
	
	/*int r = rand() % 4;
	if (r == 0 || r == 3)
	{*/
		// Boxes, barrels
		int count = (rand() % 2) + 1;
		for (int i = 0; i < count; ++i)
		{
			obj.type = genList1[rand() % 3];
			obj.pos = area.generateGroundPosition();
			objects.push_back(obj);
		}
	/*}
	else if (r == 1)
	{
		// 2 guard spheres
		for (int i = 0; i < 2; ++i)
		{
			obj.type = "guard sphere";
			obj.pos = area.generateAirPosition();
			objects.push_back(obj);
		}
	}
	else if (r == 2)
	{
		// 1 rebel gaurd sphere
		obj.type = "guard sphere - rebels";
		obj.pos = area.generateAirPosition();
		objects.push_back(obj);
	}*/

	// TODO!
	// For now, just create 2 guard spheres ...
	/*
	for (int i = 0; i < 2; ++i)
	{
		obj.type = "guard sphere";
		obj.pos = area.generateAirPosition();
		objects.push_back(obj);
	}
	*/
}

Level::Level(float scale)
{
	this->scale = scale;
}
Level::~Level()
{
	for (int i = 0; i < NUM_LEVELS; i++)
	{
		for (int k = 0; k < NUM_LEVEL_LAYERS; k++)
		{
			for (ElementListItr it = elements[i][k].begin(); it != elements[i][k].end(); ++it)
				delete (*it);

			elements[i][k].clear();
		}
		
		for (TextureListItr it = textures[i].begin(); it != textures[i].end(); ++it)
			delete (*it);
	}
}

void Level::generate()
{
	ElementList elist[2];
	float startHeight, endHeight;

	// +++ LEVEL 0 +++
	actLevel = 0;

	// Texturing for space before level 0
	if (actLevel == 0)
	{
		textures[actLevel].push_back(new LevelTextureElementAutotexCube(
			Point3(-999999, -999999, -999999),
			Point3(0, 999999, 999999),
			texTop[actLevel], texSide[actLevel], texInner1[actLevel], texInner2[actLevel]));
	}

	// Generate first entrances
	LevelElement* startPlatform = new LevelElementCube(Point3(15, 0, 0), 10, 6, 7);
	textures[actLevel].push_back(new LevelTextureElementSolidCube(Point3(startPlatform->bbMin.x-1, startPlatform->bbMin.y-1, startPlatform->bbMin.z-1),
																  Point3(startPlatform->bbMax.x+1, startPlatform->bbMax.y+1, startPlatform->bbMax.z+1), TEXATLASNUMBER_GRASS01));
	elements[0][0].push_back(startPlatform);
	elist[0].push_back(startPlatform);

	startHeight = 5;
	endHeight = 5;
	//endHeight = -35;

	// Generate starting equipment
	generateObj_StartingEquipment(Point3(10, 7.2f, 0));

	// Generate first exits
	/*createRandomCubesAt(Vector3(LEVEL_LENGTH, endHeight - 15, -50),
						Vector3(LEVEL_LENGTH, endHeight + 15, 50),
						Vector3(-2, 4, 4),
						Vector3(-2, 8, 8),
	  					15, 3, false, elist[1]);*/

	createRandomSpheresAt(Vector3(LEVEL_LENGTH, endHeight - 15, -50),
						  Vector3(LEVEL_LENGTH, endHeight + 15, 50),
						  4, 8, 15, 3, false, elist[1]);

	// Add the exits to the next level as they are
	for (int i = 0; i < (int)elist[1].size(); i++)
		elements[1][0].push_back(new LevelElementSphere(*(LevelElementSphere*)(elist[1][i])));

	// Generate first level
	//generate_RockField(elist[0], elist[1], startHeight, endHeight);
	generate_City(elist[0], elist[1], startHeight, endHeight);	// TODO: elist[1] is leaked. Find the right place to delete the contents.
	//generate_Cave(elist[0], elist[1], startHeight, endHeight);

	// +++ LEVEL 1 +++
	actLevel = 1;
	startHeight = endHeight;
	endHeight += -35;

	// Calculate entrances for next level
	createEntrancesFromExits(elist[0], elist[1], 0);

	// Add the entrances for the previous level as they are
	for (int i = 0; i < (int)elist[0].size(); i++)
		elements[0][0].push_back(new LevelElementInvSphere(*(LevelElementInvSphere*)(elist[0][i])));

	// Generate second exits
	/*createRandomCubesAt(Vector3(2 * LEVEL_LENGTH, endHeight - 15, -50),
						Vector3(2 * LEVEL_LENGTH, endHeight + 15, 50),
						Vector3(-2, 4, 4),
						Vector3(-2, 8, 8),
						15, 3, false, elist[1]);*/

	createRandomSpheresAt(Vector3(2 * LEVEL_LENGTH, endHeight - 15, -50),
						  Vector3(2 * LEVEL_LENGTH, endHeight + 15, 50),
						  4, 8, 15, 3, true, elist[1]);

	// Add the exits to the next level as they are
	for (int i = 0; i < (int)elist[1].size(); i++)
		elements[2][0].push_back(new LevelElementInvSphere(*(LevelElementInvSphere*)(elist[1][i])));

	// Generate second level
	generate_Cave(elist[0], elist[1], startHeight, endHeight);

	// +++ LEVEL 2 +++
	actLevel = 2;
	startHeight = endHeight;
	endHeight += 0;

	// Texturing for space after last level
	if (actLevel == NUM_LEVELS - 1)
	{
		textures[actLevel].push_back(new LevelTextureElementAutotexCube(
			Point3(NUM_LEVELS * LEVEL_LENGTH - 1, -999999, -999999),
			Point3(999999, 999999, 999999),
			texTop[actLevel], texSide[actLevel], texInner1[actLevel], texInner2[actLevel]));
	}

	// Calculate entrances for next level
	createEntrancesFromExits(elist[0], elist[1], 1);

	// Add the entrances for the previous level as they are
	for (int i = 0; i < (int)elist[0].size(); i++)
		elements[1][0].push_back(new LevelElementSphere(*(LevelElementSphere*)(elist[0][i])));

	// Generate boss platform
	LevelElement* bossPlatform = new LevelElementCube(Point3(3 * LEVEL_LENGTH - 15, endHeight, 0), 10, 6, 10);
	elements[2][0].push_back(bossPlatform);
	elist[1].push_back(bossPlatform);

	// Generate third level
	generate_RockField(elist[0], elist[1], startHeight, endHeight);

	// Add boss platform texturing
	textures[actLevel].push_back(new LevelTextureElementSolidCube(Point3(bossPlatform->bbMin.x-1, bossPlatform->bbMin.y-1, bossPlatform->bbMin.z-1),
																  Point3(bossPlatform->bbMax.x+1, bossPlatform->bbMax.y+1, bossPlatform->bbMax.z+1), TEXATLASNUMBER_ASPHALT01));

	// +++ OBJECTS +++
	for (ObjectListItr it = objects.begin(); it != objects.end(); ++it)
	{
		Object* obj = new Object();
		obj->name = (*it).type.c_str();
		obj->id = INVALID_OBJECT_ID;	// so the gameDataStorage knows that this object has to be created first
		obj->position = (*it).pos;
		gameDataStorage.storeObject(obj);
	}
	objects.clear();
}

void Level::createEntrancesFromExits(ElementList& dest, ElementList& src, int n)
{
	dest.clear();
	for (int k = 0; k < (int)src.size(); k++)
	{
		//LevelElement* exit = src[k];
		//LevelElementCube* entrance = new LevelElementCube(exit->midPoint + Point3(0, (((n % 2) == 0) ? 1 : -1) * (exit->bbMax.y - exit->bbMin.y), 0), (exit->bbMax.x - exit->bbMin.x) / 2, (exit->bbMax.y - exit->bbMin.y) / 2, (exit->bbMax.z - exit->bbMin.z) / 2);

		LevelElement* entrance;
		if ((n % 2) == 0)
		{
			LevelElementSphere* exit = (LevelElementSphere*)src[k];
			entrance = new LevelElementInvSphere(exit->getMidPoint() + Point3(0, exit->getRadius(), 0), exit->getRadius() / 2);
		}
		else
		{
			LevelElementInvSphere* exit = (LevelElementInvSphere*)src[k];
			entrance = new LevelElementSphere(exit->getMidPoint() + Point3(0, -exit->getRadius(), 0), exit->getRadius() / 2);
		}
		dest.push_back(entrance);
	}
	src.clear();
}

Point3 Level::getRandomFreePosition(Point3 min, Point3 max, PositionList& blockerList, float mindist)
{
	const int MAX_FAILED_ATTEMPTS = 50;
	const float mindistSq = mindist * mindist;

	bool forbiddenPos;
	Point3 pos;

	for (int i = 0; i < MAX_FAILED_ATTEMPTS; ++i)
	{
		forbiddenPos = false;
		pos = Point3(Math::RangeRandom(min.x, max.x), Math::RangeRandom(min.y, max.y), Math::RangeRandom(min.z, max.z));

		for (int k = 0; k < (int)blockerList.size(); ++k)
		{
			if (pos.squaredDistance(blockerList[k]) < mindistSq)
			{
				forbiddenPos = true;
				break;
			}
		}

		if (!forbiddenPos)
			return pos;
	}

	// Failed to find a valid position, must return an invalid one
	return pos;
}

void Level::createRandomSpheresAt(Vector3 min, Vector3 max, int rmin, int rmax, int mindist, int num, bool inversed, ElementList& out, float radiusCap)
{
	int mindistSq = mindist * mindist;
	Vector3* positions = new Vector3[num];
	int numFailed = 0;
	bool forbiddenPos = false;

	for (int i = 0; (i < num) && (numFailed < 50); i++)
	{
		Vector3 pos = Vector3(Math::RangeRandom(min.x, max.x), Math::RangeRandom(min.y, max.y), Math::RangeRandom(min.z, max.z));

		// Check if the minimum distance requirement is met
		for (int k = 0; k < i; k++)
		{
			if (positions[k].squaredDistance(pos) < mindistSq)
			{
				forbiddenPos = true;
				break;
			}
		}
		if (forbiddenPos)
		{
			forbiddenPos = false;
			i--;
			numFailed++;
			continue;
		}

		int radius = (int)Math::RangeRandom(rmin, rmax);
		if (inversed)
		{
			LevelElementInvSphere* sphere = new LevelElementInvSphere(Point3(pos.x, pos.y, pos.z), radius);
			if (radiusCap < 1.0f)
				sphere->bbMin.y = sphere->bbMax.y - radius - radius * radiusCap;
			out.push_back(sphere);
		}
		else
		{
			LevelElementSphere* sphere = new LevelElementSphere(Point3(pos.x, pos.y, pos.z), radius);
			if (radiusCap < 1.0f)
				sphere->bbMax.y = sphere->bbMin.y + radius + radius * radiusCap;
			out.push_back(sphere);
		}
		positions[i] = pos;
	}

	delete[] positions;
}

void Level::createRandomCubesAt(Vector3 min, Vector3 max, Vector3 rmin, Vector3 rmax, int mindist, int num, bool inversed, ElementList& out)
{
	int mindistSq = mindist * mindist;
	Vector3* positions = new Vector3[num];
	int numFailed = 0;
	bool forbiddenPos = false;

	for (int i = 0; (i < num) && (numFailed < 50); i++)
	{
		Vector3 pos = Vector3(Math::RangeRandom(min.x, max.x), Math::RangeRandom(min.y, max.y), Math::RangeRandom(min.z, max.z));

		// Check if the minimum distance requirement is met
		for (int k = 0; k < i; k++)
		{
			if (positions[k].squaredDistance(pos) < mindistSq)
			{
				forbiddenPos = true;
				break;
			}
		}
		if (forbiddenPos)
		{
			forbiddenPos = false;
			i--;
			numFailed++;
			continue;
		}

		Vector3 radius = Vector3(Math::RangeRandom(rmin.x, rmax.x), Math::RangeRandom(rmin.y, rmax.y), Math::RangeRandom(rmin.z, rmax.z));
		if (inversed)
			out.push_back(new LevelElementInvCube(Point3(pos.x, pos.y, pos.z), radius.x, radius.y, radius.z));
		else
			out.push_back(new LevelElementCube(Point3(pos.x, pos.y, pos.z), radius.x, radius.y, radius.z));
		positions[i] = pos;
	}

	delete positions;
}

void Level::getLevelElementsInRange(int levelNumber, int firstX, int firstY, int firstZ, int lastX, int lastY, int lastZ)
{
	for (int l = 0; l < NUM_LEVEL_LAYERS; l++)
	{
		for (ElementListItr it = elements[levelNumber][l].begin(); it != elements[levelNumber][l].end(); ++it)
		{
			if ((lastX < (*it)->bbMin.x) || (firstX > (*it)->bbMax.x) || (lastY < (*it)->bbMin.y) || (firstY > (*it)->bbMax.y) || (lastZ < (*it)->bbMin.z) || (firstZ > (*it)->bbMax.z))
				continue;

			tempElementList[l][tempElementListSize[l]] = *it;
			tempElementListSize[l]++;
		}
	}
}
int Level::create(int firstX, int firstY, int firstZ, int lastX, int lastY, int lastZ, int blx, int bly, int baseX, int levelNumber, int levelTransMin, int levelTransMax, bool oneLevel, char* buffer)
{
	assert(firstX <= lastX);

	// If the level number is out of range, fill the section and return
	if ((levelNumber < 0) || (levelNumber >= NUM_LEVELS))
	{
		if (oneLevel)
		{
			return RETURN_FULL_BLOCK;
		}
		else
		{
			// Can't use memset here because the section may be only part of the buffer
			for (int x = firstX; x <= lastX; x++)
				for (int y = firstY; y <= lastY; y++)
					for (int z = firstZ; z <= lastZ; z++)
						buffer[(x - baseX) + (y - firstY) * blx + (z - firstZ) * blx * bly] = 127;
			return RETURN_NORMAL_BLOCK;
		}
	}

	// Sort out level elements not touching this sector (separately for every layer), save relevant elements in tempElementList
	for (int l = 0; l < NUM_LEVEL_LAYERS; l++)
		tempElementListSize[l] = 0;

	getLevelElementsInRange(levelNumber, firstX, firstY, firstZ, lastX, lastY, lastZ);

	// Add neighbouring levels if close to level boundary
	if ((levelNumber >= 1) && (firstX - levelTransMin < 5))
		getLevelElementsInRange(levelNumber - 1, firstX, firstY, firstZ, lastX, lastY, lastZ);
	if ((levelNumber < NUM_LEVELS - 1) && (levelTransMax - lastX < 5))
		getLevelElementsInRange(levelNumber + 1, firstX, firstY, firstZ, lastX, lastY, lastZ);

	// Quick return if completely full or empty and we own the whole buffer
	if (oneLevel)
	{
		int l = 0;
		for (; l < NUM_LEVEL_LAYERS; l++)
			if (tempElementListSize[l] > 0)
				break;

		if (l == NUM_LEVEL_LAYERS)
		{
			// No elements in this block. Return!
			if (levelNumber % 2 == 0)
				return RETURN_EMPTY_BLOCK;
			else
				return RETURN_FULL_BLOCK;
		}
	}

	// For every voxel in the block ...
	for (int x = firstX; x <= lastX; x++)
	{
		for (int y = firstY; y <= lastY; y++)
		{
			for (int z = firstZ; z <= lastZ; z++)
			{
				float value;

				// Set starting value based on the level number
				if (levelNumber % 2 == 0)
					value = -1.0f;
				else
					value = 1.0f;

				// Apply all layers of elements
				for (int l = 0; l < NUM_LEVEL_LAYERS; l++)
				{
					// Apply all elements
					for (int e = 0; e < tempElementListSize[l]; e++)
					{
						LevelElement* elem = tempElementList[l][e];
						if ((x < elem->bbMin.x) || (x > elem->bbMax.x) || (y < elem->bbMin.y) || (y > elem->bbMax.y) || (z < elem->bbMin.z) || (z > elem->bbMax.z))
							continue;

						value = elem->apply(x, y, z, value);
					}

					// clamp value to [-1; 1]
					if (value > 1)			value = 1;
					else if (value < -1)	value = -1;
				}

				buffer[(x - baseX) + (y - firstY) * blx + (z - firstZ) * blx * bly] = (char)(value * 127);
			}
		}
	}

	return RETURN_NORMAL_BLOCK;
}

int Level::createFunc(int firstX, int firstY, int firstZ, int lastX, int lastY, int lastZ, char* buffer)
{
	const int blx = lastX - firstX + 1;
	const int bly = lastY - firstY + 1;

	int lowLevel = firstX / (int)(LEVEL_LENGTH * level->scale + 0.5f);
	if (firstX < 0)
		lowLevel--;

	int highLevel = lastX / (int)(LEVEL_LENGTH * level->scale + 0.5f);
	if (lastX < 0)
		highLevel--;

	if (lowLevel == highLevel)
		return level->create(firstX, firstY, firstZ, lastX, lastY, lastZ, blx, bly, firstX, lowLevel, lowLevel * LEVEL_LENGTH * level->scale, (1+lowLevel) * LEVEL_LENGTH * level->scale, true, buffer);
	else
	{
		if (highLevel < 0)
		{
			level->create(firstX, firstY, firstZ, highLevel * LEVEL_LENGTH * level->scale, lastY, lastZ, blx, bly, firstX, lowLevel, lowLevel * LEVEL_LENGTH * level->scale, highLevel * LEVEL_LENGTH * level->scale, false, buffer);
			level->create(highLevel * LEVEL_LENGTH * level->scale + 1, firstY, firstZ, lastX, lastY, lastZ, blx, bly, firstX, highLevel, highLevel * LEVEL_LENGTH * level->scale, (1+highLevel) * LEVEL_LENGTH * level->scale, false, buffer);
		}
		else
		{
			level->create(firstX, firstY, firstZ, highLevel * LEVEL_LENGTH * level->scale - 1, lastY, lastZ, blx, bly, firstX, lowLevel, lowLevel * LEVEL_LENGTH * level->scale, highLevel * LEVEL_LENGTH * level->scale, false, buffer);
			level->create(highLevel * LEVEL_LENGTH * level->scale, firstY, firstZ, lastX, lastY, lastZ, blx, bly, firstX, highLevel, highLevel * LEVEL_LENGTH * level->scale, (1+highLevel) * LEVEL_LENGTH * level->scale, false, buffer);
		}
	}

	return RETURN_NORMAL_BLOCK;
}

void Level::getLevelTexturesInRange(int levelNumber, int firstX, int firstY, int firstZ, int lastX, int lastY, int lastZ)
{
	for (TextureListItr it = textures[levelNumber].begin(); it != textures[levelNumber].end(); ++it)
	{
		if ((lastX < (*it)->bbMin.x) || (firstX > (*it)->bbMax.x) || (lastY < (*it)->bbMin.y) || (firstY > (*it)->bbMax.y) || (lastZ < (*it)->bbMin.z) || (firstZ > (*it)->bbMax.z))
			continue;

		tempTextureList[tempTextureListSize] = *it;
		tempTextureListSize++;
	}
}
void Level::createTex(int firstX, int firstY, int firstZ, int lastX, int lastY, int lastZ, int blx, int bly, int baseX, int levelNumber, char* voxelBuffer, unsigned char* buffer)
{
	assert(firstX <= lastX);

	// If the level number is out of range, clamp it
	if (levelNumber < 0)			levelNumber = 0;
	if (levelNumber >= NUM_LEVELS)	levelNumber = NUM_LEVELS - 1;

	// Sort out level elements not touching this sector, save relevant elements in tempTextureList
	tempTextureListSize = 0;
	getLevelTexturesInRange(levelNumber, firstX, firstY, firstZ, lastX, lastY, lastZ);

	// Apply all level texture elements
	for (int e = 0; e < tempTextureListSize; e++)
	{
		LevelTextureElement* elem = tempTextureList[e];

		elem->apply(max(firstX-baseX, elem->bbMin.x-baseX), max(0, elem->bbMin.y-firstY), max(0, elem->bbMin.z-firstZ),
					min(lastX - baseX, elem->bbMax.x-baseX), min(lastY - firstY, elem->bbMax.y-firstY), min(lastZ - firstZ, elem->bbMax.z-firstZ),
					baseX, firstY, firstZ,
					voxelBuffer, buffer);
	}
}

void Level::textureFunc(int firstX, int firstY, int firstZ, int lastX, int lastY, int lastZ, char* voxelBuffer, unsigned char* buffer)
{
	const int blx = lastX - firstX + 1;
	const int bly = lastY - firstY + 1;

	int lowLevel = firstX / (int)(LEVEL_LENGTH * level->scale + 0.5f);
	if (firstX < 0)
		lowLevel--;

	int highLevel = lastX / (int)(LEVEL_LENGTH * level->scale + 0.5f);
	if (lastX < 0)
		highLevel--;

	if (lowLevel == highLevel)
		return level->createTex(firstX, firstY, firstZ, lastX, lastY, lastZ, blx, bly, firstX, lowLevel, voxelBuffer, buffer);
	else
	{
		if (highLevel < 0)
		{
			level->createTex(firstX, firstY, firstZ, highLevel * LEVEL_LENGTH * level->scale, lastY, lastZ, blx, bly, firstX, lowLevel, voxelBuffer, buffer);
			level->createTex(highLevel * LEVEL_LENGTH * level->scale + 1, firstY, firstZ, lastX, lastY, lastZ, blx, bly, firstX, highLevel, voxelBuffer, buffer);
		}
		else
		{
			level->createTex(firstX, firstY, firstZ, highLevel * LEVEL_LENGTH * level->scale - 1, lastY, lastZ, blx, bly, firstX, lowLevel, voxelBuffer, buffer);
			level->createTex(highLevel * LEVEL_LENGTH * level->scale, firstY, firstZ, lastX, lastY, lastZ, blx, bly, firstX, highLevel, voxelBuffer, buffer);
		}
	}
}

Vector3 Level::pointToVector(const Point3& point)
{
	return Vector3(point.x * game.volumeData->scale, point.y * game.volumeData->scale, point.z * game.volumeData->scale);
}

// --- Level::Connection ---
Level::Connection::Connection(Vector3 start, Vector3 end)
{
	this->start = start;
	this->end = end;
	midPoint = this->start.midPoint(this->end);
	lengthSq = this->start.squaredDistance(this->end);
}

Level::Connection::Connection(LevelElement* start, LevelElement* end)
{
	this->start = Vector3(start->midPoint.x, start->midPoint.y, start->midPoint.z)  / level->scale;
	this->end = Vector3(end->midPoint.x, end->midPoint.y, end->midPoint.z) / level->scale;
	midPoint = this->start.midPoint(this->end);
	lengthSq = this->start.squaredDistance(this->end);
}
