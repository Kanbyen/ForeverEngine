/*****************************************************************************************

Forever War - a NetHack-like FPS

Copyright (C) 2008 Thomas Sch√∂ps

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program;
if not, see <http://www.gnu.org/licenses/>.

*****************************************************************************************/

#include "precompiled.h"
#include "stateGame.h"
#include "settings.h"
#include "physics.h"
#include "windowManager.h"
#include "stateManager.h"
#include "object.h"
#include "componentPlayer.h"
#include "console.h"
#include "volume.h"
#include "level.h"
#include "aiFactionManager.h"
#include "skysphere.h"
#include "gameDataStorage.h"
#include "objectScript.h"
#include "input.h"
#include "stateGameInputHandler.h"
#include "gameMode.h"
#include "digiSpe.h"

#include "textureAtlas.h" // automatically generated by texatlas
#include <network.h>

const float LEVEL_SCALE_NORMAL = 1.0f;

Game game;

Vector3 Game::lastEditPos;

bool Game::click_generate(const CEGUI::EventArgs &args)
{
	CEGUI::WindowEventArgs& wArgs = (CEGUI::WindowEventArgs&)args;

	if (wArgs.window == CEGUI::WindowManager::getSingleton().getWindow("Generate_Invert"))
		Level::other_Invert();
	else
	{
		objectManager.deleteAllObjects();
		gameDataStorage.clear();
		volumeData->reset();
		volumeData->setBlockTextureCallback(&Level::other_autotexCallback);

		// If there is already a level, delete it
		delete level;
		level = NULL;

		if (wArgs.window == CEGUI::WindowManager::getSingleton().getWindow("Generate_Cube"))
			volumeData->setBlockLoadCallback(&Level::other_Cube_VoxelCB);
		else if (wArgs.window == CEGUI::WindowManager::getSingleton().getWindow("Generate_Sphere"))
			volumeData->setBlockLoadCallback(&Level::other_Sphere_VoxelCB);
		else if (wArgs.window == CEGUI::WindowManager::getSingleton().getWindow("Generate_PerlinNoise"))
			volumeData->setBlockLoadCallback(&Level::other_Perlin_VoxelCB);
		else if (wArgs.window == CEGUI::WindowManager::getSingleton().getWindow("Generate_Planes"))
			volumeData->setBlockLoadCallback(&Level::other_Planes_VoxelCB);
		else if (wArgs.window == CEGUI::WindowManager::getSingleton().getWindow("Generate_Terrain"))
			volumeData->setBlockLoadCallback(&Level::other_Terrain_VoxelCB);
		else if (wArgs.window == CEGUI::WindowManager::getSingleton().getWindow("Generate_PerlinNoiseCave"))
			volumeData->setBlockLoadCallback(&Level::other_Cave_VoxelCB);
		else
		{
			// Forever War level
			// Create level data
			if (wArgs.window == CEGUI::WindowManager::getSingleton().getWindow("Generate_ForeverWar"))
				level = new Level(LEVEL_SCALE_NORMAL);
			else
				level = new Level(0.4f);

   			level->generate();

			volumeData->setBlockLoadCallback(&Level::createFunc);
			volumeData->setBlockTextureCallback(&Level::textureFunc);
		}
	}

	return true;
}

void Game::createVoxelGeometry()
{
	#if defined( DIGISPE )
		volumeData = new VoxelVolume(VOLUME_SIDE_LENGTH, VOLUME_SIDE_LENGTH, VOLUME_SIDE_LENGTH, 1.5f, true);
	#else
		volumeData = new VoxelVolume(VOLUME_SIDE_LENGTH, VOLUME_SIDE_LENGTH, VOLUME_SIDE_LENGTH, 1.0f, true);
	#endif

	// Automatic paging is enabled by default
	volumeData->automaticPaging = true;
	volumeData->pagingMode = PAGINGMODE_OPEN;
	volumeData->lastPagingPos = Vector3(-99999, 99999, 99999);	// = "far away from any reasonable position"
}

void Game::createScene()
{
	// Don't clear color every frame as we have a skySphere
	vp->setClearEveryFrame(true, FBT_DEPTH);

	// Set lighting
	sceneMgr->setAmbientLight(ColourValue(0.2, 0.2, 0.2));

	/*sceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
	sceneMgr->setShadowCameraSetup(ShadowCameraSetupPtr(new FocusedShadowCameraSetup()));
	sceneMgr->setShadowTextureSize(512);
	sceneMgr->setShadowColour(ColourValue(0.6, 0.6, 0.6));

	Light *light = sceneMgr->createLight("Light1");
	light->setType(Light::LT_DIRECTIONAL);
	light->setDirection(0, -0.957826285, 0.287347886);
	light->setDiffuseColour(ColourValue(0.85, 0.85, 0.85));*/

	// Create volume
	createVoxelGeometry();

	// Create skySphere
	skySphere = new SkySphere("SkySphereMaterial");

	// Create physics
	physics.init(volumeData);

	// Setup fog
	displayFog = false;
	fogColor = ColourValue(0.7f, 0.7f, 1.0f, 0.0f);
	fogMinimumDistance = ((VOLUME_RADIUS * BLOCK_SIDE_LENGTH - 8.0f) - 34.0f) * volumeData->scale;
	fogMaximumDistance = (VOLUME_RADIUS * BLOCK_SIDE_LENGTH - 20.0f) * volumeData->scale;
	cutoffAfterFogMaxDist = true;
	updateFog();	// Fog will be activated depending on the state of the fog checkbox


	// Hide loading screen
	OverlayManager::getSingleton().getByName("LoadingOverlay")->hide();

	// Show the mouse cursor
	windowManager.showMouseCursorHack();
}

void Game::setFog(float r, float g, float b, float mindist, float maxdist, bool cutoff)
{
	// TODO: not especially elegant. Do we have to use the CEGUI stuff?
	CEGUI::Checkbox* checkbox = (CEGUI::Checkbox*)CEGUI::WindowManager::getSingleton().getWindow("DisplayFog");
	checkbox->setSelected(true);
	displayFog = false;
	
	fogColor = ColourValue(r, g, b, 0.0f);
	fogMinimumDistance = mindist * VOLUME_RADIUS * BLOCK_SIDE_LENGTH;
	fogMaximumDistance = maxdist * VOLUME_RADIUS * BLOCK_SIDE_LENGTH;
	cutoffAfterFogMaxDist = cutoff;
}
void Game::updateFog()
{
	CEGUI::Checkbox* checkbox = (CEGUI::Checkbox*)CEGUI::WindowManager::getSingleton().getWindow("DisplayFog");

	if (checkbox->isSelected())
	{
		if (!displayFog)
		{
            camera->setFarClipDistance(cutoffAfterFogMaxDist ? (fogMaximumDistance - 1.0f) : (VOLUME_RADIUS * BLOCK_SIDE_LENGTH * 1.6f));
            sceneMgr->setFog(FOG_LINEAR, fogColor, 0, fogMinimumDistance, fogMaximumDistance);
		}
		skySphere->update(camera, cutoffAfterFogMaxDist ? (fogMaximumDistance - 2.0f) : (VOLUME_RADIUS * BLOCK_SIDE_LENGTH * 1.6f - 1.0f));
	}
	else if (!checkbox->isSelected())
	{
	    if (displayFog)
	    {
            camera->setFarClipDistance(2 * 1024.0f);
            sceneMgr->setFog(FOG_LINEAR, ColourValue(0, 0, 0, 0.0f), 0, 9000, 10000);
	    }
		skySphere->update(camera, 2 * 1024.0f - 1.0f);
	}

	displayFog = checkbox->isSelected();
}

void Game::updateGUI(float timeSinceLastFrame)
{
	gameConsole->update(timeSinceLastFrame);
	descConsole->update(timeSinceLastFrame);

	CEGUI::Window* wnd = CEGUI::WindowManager::getSingleton().getWindow("YourPos");
	int x = (cameraNode->_getDerivedPosition().x) / (BLOCK_SIDE_LENGTH * volumeData->scale);	if (cameraNode->_getDerivedPosition().x < 0) x--;
	int y = (cameraNode->_getDerivedPosition().y) / (BLOCK_SIDE_LENGTH * volumeData->scale);	if (cameraNode->_getDerivedPosition().y < 0) y--;
	int z = (cameraNode->_getDerivedPosition().z) / (BLOCK_SIDE_LENGTH * volumeData->scale);	if (cameraNode->_getDerivedPosition().z < 0) z--;
	wnd->setText("Your pos: " + Ogre::StringConverter::toString(x) + ", " + Ogre::StringConverter::toString(y) + ", " + Ogre::StringConverter::toString(z));
	wnd = CEGUI::WindowManager::getSingleton().getWindow("VolumePos");
	wnd->setText("Volume pos: " + Ogre::StringConverter::toString(volumeData->windowXInBlocks) + ", " + Ogre::StringConverter::toString(volumeData->windowYInBlocks) + ", " + Ogre::StringConverter::toString(volumeData->windowZInBlocks));
}

void Game::setNewAutotexSettings()
{
	CEGUI::Window* wnd = CEGUI::WindowManager::getSingleton().getWindow("AutotexTopEdit");
	wnd->setText(StringConverter::toString(autotexTop));

	wnd = CEGUI::WindowManager::getSingleton().getWindow("AutotexSideEdit");
	wnd->setText(StringConverter::toString(autotexSide));

	wnd = CEGUI::WindowManager::getSingleton().getWindow("AutotexInner1Edit");
	wnd->setText(StringConverter::toString(autotexInner1));

	wnd = CEGUI::WindowManager::getSingleton().getWindow("AutotexInner2Edit");
	wnd->setText(StringConverter::toString(autotexInner2));
}
void Game::setAutotexSettings(int top, int side, int inner1, int inner2)
{
	autotexTop = top;
	autotexSide = side;
	autotexInner1 = inner1;
	autotexInner2 = inner2;
}

void Game::setNewVolumeScale()
{
	CEGUI::Window* wnd = CEGUI::WindowManager::getSingleton().getWindow("VolumeScaleEdit");
	wnd->setText(StringConverter::toString(volumeData->scale));
}

void Game::setNewBrushSize()
{
	CEGUI::Window* wnd = CEGUI::WindowManager::getSingleton().getWindow("BrushSizeEdit");
	wnd->setText(StringConverter::toString(brushSize));
}

void Game::setNewBrushTexture()
{
	CEGUI::Window* wnd = CEGUI::WindowManager::getSingleton().getWindow("BrushTextureEdit");
	wnd->setText(StringConverter::toString(brushTexture));
}

void Game::setSavePath(const char* path)
{
	savePath = path;
}
void Game::setSubState(EGameSubState subState)
{
	this->subState = subState;
	
	if (subState == SUBST_GAMESTART)
	{
		lastLoadingPercentageSent = -1;
		gameCanBeStarted = false;
		
		#ifndef DIGISPE
		network->setState(NETSTATE_GAMESTART);
		
		windowManager.setPage("GameStart");
		if (network->isServer())
			CEGUI::WindowManager::getSingleton().getWindow("GameStartInstructions")->setText("Press Esc to shutdown the server");
		else
			CEGUI::WindowManager::getSingleton().getWindow("GameStartInstructions")->setText("Press Esc to disconnect");
		
		CEGUI::Editbox* chatBox = (CEGUI::Editbox*)CEGUI::WindowManager::getSingleton().getWindow("GameStartChat");
		chatBox->activate();
		#endif
	}
	else if (subState == SUBST_PLAY)
	{
		#ifndef DIGISPE
		if (network)
			network->setState(NETSTATE_PLAYING);
		#endif
	}
	else if (subState == SUBST_RESPAWN)
	{
		// TODO!
	}
}

void Game::init(State* lastState)
{
	// Register ourself as frame listener
	ogre->addFrameListener(&game);

	// Register correct input handler
	inputManager->setInputHandler(&gameInputHandler);
	gameInputHandler.guiInputMode = false;
	
	subState = SUBST_EDITOR;

	mPlayer = NULL;
	level = NULL;
	savePath = "save/";
	runSimulation = true;

	// Create the camera's top node (which will only handle position).
	cameraNode = sceneMgr->getRootSceneNode()->createChildSceneNode();
	cameraNode->setPosition(0, 0, 0);

	// Create the camera's yaw node as a child of camera's top node.
	cameraYawNode = cameraNode->createChildSceneNode();

	// Create the camera's pitch node as a child of camera's yaw node.
	cameraPitchNode = cameraYawNode->createChildSceneNode();

	// Create the camera's roll node as a child of camera's pitch node
	// and attach the camera to it.
	cameraRollNode = cameraPitchNode->createChildSceneNode();
	cameraRollNode->attachObject(camera);
	
	// Display the Editor HUD
	windowManager.setPage("Editor");
	
	// Create the scene
	createScene();
	
	clearMessages();
	
	// Add bloom if specified in the options
	if (settings.bloom)
	{
		CompositorManager::getSingleton().addCompositor(vp, "Bloom");
		CompositorManager::getSingleton().setCompositorEnabled(vp, "Bloom", true);
	}
	
	// set the first brush size, brush texture and autotex settings, etc.
	brushSize = 7.0f;
	setNewBrushSize();
	brushTexture = 0;
	setNewBrushTexture();
	
	// Initialize consoles
	gameConsole = new Console(CEGUI::WindowManager::getSingleton().getWindow("HUDRoot"), 0.03f, 0.63f, 10, 8.0f, 0.2f);
	descConsole = new Console(CEGUI::WindowManager::getSingleton().getWindow("HUDRoot"), 0.97f, 0.85f, 30, 15.0f, 0.2f, TEXTALIGN_RIGHT, true);
	
	// Set default autotex settings
	autotexTop = TEXATLASNUMBER_GRASS01;
	autotexSide = TEXATLASNUMBER_LARGE_BRICKS01;
	autotexInner1 = TEXATLASNUMBER_SAND01;
	autotexInner2 = TEXATLASNUMBER_ROCK01;
	setNewAutotexSettings();

	// Set default volume scale
	setNewVolumeScale();
	
	
	// Let the active game mode do the game mode initialization
	gameModeManager.doGameModeInitialization();
	
	// TODO: put this into a script
	newGame();
	
	frameNumber = 0;
}

void Game::exit(State* nextState)
{
	ogre->removeFrameListener(&game);

	delete gameConsole;

	if (mPlayer)
		objectManager.deleteObject(mPlayer->object);

	objectManager.exit();			// TODO: Inconsitency with init/exit: exit in Game, init in initData of main.cpp
	endGame();
	objectScriptManager.exit();		// TODO: as above

	delete volumeData;
	delete skySphere;
	delete level;

	physics.exit();
	sceneMgr->clearScene();
}

void Game::moveCamera(Radian rotX, Radian rotY, Vector3 translateVector)
{
	Real pitchAngle;
	Real pitchAngleSign;

	// Yaws the camera according to the mouse relative movement.
	cameraYawNode->yaw(rotX);

	// Pitches the camera according to the mouse relative movement.
	cameraPitchNode->pitch(rotY);

	if (!mPlayer)
	{
		// Translates the camera according to the translate vector which is
		// controlled by the keyboard arrows.
		//
		// We multiply the mTranslateVector by the cameraPitchNode's
		// orientation quaternion and the cameraYawNode's orientation
		// quaternion to translate the camera accoding to the camera's
		// orientation around the Y-axis and the X-axis.
		cameraNode->translate(cameraYawNode->getOrientation() *
									cameraPitchNode->getOrientation() *
									translateVector,
									SceneNode::TS_LOCAL);
	}

	// Angle of rotation around the X-axis.
	pitchAngle = (2 * Degree(Math::ACos(cameraPitchNode->getOrientation().w)).valueDegrees());

	// Just to determine the sign of the angle we pick up above, the
	// value itself does not interest us.
	pitchAngleSign = cameraPitchNode->getOrientation().x;

	// Limit the pitch between -90 degress and +90 degrees
	if (pitchAngle > 90.0f)
	{
		if (pitchAngleSign > 0)			// Set orientation to 90 degrees on X-axis.
			cameraPitchNode->setOrientation(Quaternion(Math::Sqrt(0.5f), Math::Sqrt(0.5f), 0, 0));
		else if (pitchAngleSign < 0)	// Sets orientation to -90 degrees on X-axis.
			cameraPitchNode->setOrientation(Quaternion(Math::Sqrt(0.5f), -Math::Sqrt(0.5f), 0, 0));
	}
}
void Game::setCameraPosition(Vector3 pos)
{
	cameraNode->setPosition(pos);
}
Vector3 Game::getCameraPosition()
{
	return cameraNode->_getDerivedPosition();
}
Vector3 Game::getCameraForward()
{
	return cameraYawNode->getOrientation() * Vector3(0, 0, 1);
}
Vector3 Game::getCameraRight()
{
	return cameraYawNode->getOrientation() * Vector3(1, 0, 0);
}
SceneNode* Game::getCameraRollNode()
{
	return cameraRollNode;
}
SceneNode* Game::getCameraNode()
{
	return cameraNode;
}
void Game::setCameraNodeOrientations(Quaternion yaw, Quaternion pitch, Quaternion roll)
{
	cameraYawNode->setOrientation(yaw);
	cameraPitchNode->setOrientation(pitch);
	cameraRollNode->setOrientation(roll);
}

void Game::updateGameStart()
{
	#ifndef DIGISPE
	// Get loading percentage and send it to other players
	int loadingPercentage = (100 * volumeData->getLoadedBlocks()) / VOLUME_NUM_BLOCKS;
	if (loadingPercentage != lastLoadingPercentageSent)
	{
		network->loadingPercentageChanged(loadingPercentage);
		lastLoadingPercentageSent = loadingPercentage;
	}
	
	// Can the game be started?
	if (network->isServer())
	{
		if (!gameCanBeStarted && loadingPercentage == 100)
		{
			// If everyone is ready, enable starting the game
			if (network->areAllPlayersReady())
			{
				gameCanBeStarted = true;
				CEGUI::WindowManager::getSingleton().getWindow("GameStartInstructions")->setText("Press F5 to start the game,\r\nEsc to shutdown the server");
			}
		}
		else if (gameCanBeStarted)
		{
			// If a new player joined, disable starting the game
			if (!network->areAllPlayersReady())
			{
				gameCanBeStarted = false;
				CEGUI::WindowManager::getSingleton().getWindow("GameStartInstructions")->setText("Press Esc to shutdown the server");
			}
		}
	}
	
	// Update player list
	const Network::PlayerList playerList = network->getPlayerList();
	CEGUI::Listbox* listbox = (CEGUI::Listbox*)CEGUI::WindowManager::getSingleton().getWindow("GameStartPlayerlist");
	
	// TODO: Don't use polling for this
	listbox->resetList();
	for (size_t i = 0; i < playerList.size(); ++i)
	{
		if (!network->isServer() || playerList[i]->ready)
		{
			ostringstream o;
			o << playerList[i]->score;
			listbox->addItem(new MyListItem(playerList[i]->nickname + " (loaded: " + o.str() + "%)", playerList[i]));
		}
		else
			listbox->addItem(new MyListItem(playerList[i]->nickname, playerList[i]));
	}
	
	// Update messages
	int numNewMessages = getNumNewMessagesThisFrame();
	CEGUI::Listbox* messagesbox = (CEGUI::Listbox*)CEGUI::WindowManager::getSingleton().getWindow("GameStartMessages");
	for (int i = 0; i < numNewMessages; ++i)
	{
		// TODO: line coloring/formatting based on message type
		string msg = getNthLatestMessage(i);
		MyListItem* newItem = new MyListItem(msg, NULL);
		messagesbox->addItem(newItem);
		messagesbox->ensureItemIsVisible(newItem);	// TODO: do this only if list is scrolled down completely
	}
	#endif
}

bool Game::frameStarted(const FrameEvent& evt)
{
	// Prevent too big time steps
	float timeStep = evt.timeSinceLastFrame;
	if (timeStep > 0.6f)
		timeStep = 0.001f;

	// Handle input and react on it using the game input handler
	inputManager->capture(timeStep);
	if (stateManager.getActState() != this)
		return false;

	// Run game logic
	if (runSimulation)
		updateObjects(timeStep);
	objectManager.updateManager();

	// Account for changes in geometry
	volumeData->update(cameraNode->_getDerivedPosition());

	// Run physics simulation
	if (runSimulation)
		physics.step(timeStep);
	
	// Handle networking
	#ifndef DIGISPE
	if (network)
		network->update(timeStep);
	#endif
	
	// Update fog settings
	updateFog();

	// Update GUI
	updateGUI(timeStep);
	
	if (subState == SUBST_GAMESTART)
		updateGameStart();

	// Update DigiSpe
	if (digiSpe)
		digiSpe->update(timeStep);
	
	// Mark message updates as processed
	messagesUpdated();

	return true;
}

bool Game::frameEnded(const FrameEvent& evt)
{
	return true;
}

Object* Game::createPlayer(Vector3 position)
{
	Object* obj = objectManager.createObject("player", INVALID_OBJECT_ID);
	if (!obj)
		LogManager::getSingleton().logMessage("ERROR: Game::createPlayer: failed to create object of type player!", LML_CRITICAL);
	else
		obj->sendMessage(COMPMSG_CREATE, (void*)(&position));
	return obj;
}

void Game::updateObjects(float timeSinceLastFrame)
{
	static float dt = 0.0f;
	dt += timeSinceLastFrame;

	int maxSteps = 8;
	while ((dt >= LOGIC_TIME_STEP) && (maxSteps > 0))
	{
		dt -= LOGIC_TIME_STEP;
		maxSteps--;

		// Notify objects
		objectManager.update();
		// count frames
		frameNumber++;
	}

	// If there are too much steps left, skip them
	if (dt > 1.6f)
		dt = 0;	// don't spam the log with warnings if there was just a longer calculation
	while (dt > 0.8f)
	{
		LogManager::getSingleton().logMessage("WARNING: Logic steps skipped.");
		dt -= 0.8f;
	}
}

void Game::editLevel_Hard_CB_Add(int x, int y, int z, float v)
{
	const int maxVal = std::numeric_limits<signed char>::max();
	int data = game.volumeData->getVoxelRel(x, y, z);
	data = std::min(maxVal, (int)(data + v * maxVal));
	game.volumeData->setVoxelRel(x, y, z, data);
}

void Game::editLevel_Hard_CB_Sub(int x, int y, int z, float v)
{
	const int minVal = std::numeric_limits<signed char>::min();
	int data = game.volumeData->getVoxelRel(x, y, z);
	data = std::max(minVal, (int)(data + v * minVal));
	game.volumeData->setVoxelRel(x, y, z, data);
}

void Game::editLevel_Hard(bool leftMB, Vector3 pos, Vector3 dir, int funcNumber)
{
	Vector3 hit;

	if (leftMB)
	{
		// Build
		if (game.volumeData->getRayIntersectionEx(pos, dir, &hit, 400))
		{
			if (!game.mPlayer || ((hit - pos).length() > game.brushSize + 3))
			{
				Game::editLevel_CallShapeFunc(funcNumber, hit, game.brushSize, &Game::editLevel_Hard_CB_Add);
				lastEditPos = hit;
			}
		}
	}
	else
	{
		// Remove
		if (game.volumeData->getRayIntersectionEx(pos, dir, &hit, 400))
		{
			Game::editLevel_CallShapeFunc(funcNumber, hit, game.brushSize, &Game::editLevel_Hard_CB_Sub);
			lastEditPos = hit;
		}
	}
}

void Game::editLevel_Smooth_CB_Add(int x, int y, int z, float v)
{
	const int maxVal = std::numeric_limits<signed char>::max();

	// gather sum of neighbours
	float n = 0;
	for (int dx = -1; dx < 2; dx++)
		for (int dy = -1; dy < 2; dy++)
			for (int dz = -1; dz < 2; dz++)
				if (x != 0 || y != 0 || z != 0)
					n += (game.volumeData->getVoxelRel(x + dx, y + dy, z + dz) > -30) ? 1 : 0;
	//n += maxVal * 6;
	//n = std::max(0.0f, n);
	//n /= (float)(maxVal * 6);

	if (n > 0)
	{
		v = std::min(1.0f, v);	// disable to get an alternative version
		int data = game.volumeData->getVoxelRel(x, y, z);
		//float n = std::max(0.4f, data / (float)maxVal);
		//data = std::min(maxVal, (int)(data + (v / (2 * game.brushSize)) * maxVal));
		data = std::min(maxVal, (int)(data + (v / (2 * game.brushSize)) * (n / 3.0f) * maxVal));
		game.volumeData->setVoxelRel(x, y, z, data);
	}
}

void Game::editLevel_Smooth_CB_Sub(int x, int y, int z, float v)
{
	const int minVal = std::numeric_limits<signed char>::min();

	// gather sum of neighbours
	float n = 0;
	for (int dx = -1; dx < 2; dx++)
		for (int dy = -1; dy < 2; dy++)
			for (int dz = -1; dz < 2; dz++)
				if (x != 0 || y != 0 || z != 0)
					n += (game.volumeData->getVoxelRel(x + dx, y + dy, z + dz) < 30) ? 1 : 0;

	if (n > 0)
	{
		v = std::min(1.0f, v);
		int data = game.volumeData->getVoxelRel(x, y, z);
		data = std::max(minVal, (int)(data + (v / (2 * game.brushSize)) * (n / 3.0f) * minVal));
		game.volumeData->setVoxelRel(x, y, z, data);
	}

	// old code, produces stairs
	/*float n = 0;
	n -= game.volumeData->getVoxelRel(x + 1, y, z);
	n -= game.volumeData->getVoxelRel(x - 1, y, z);
	n -= game.volumeData->getVoxelRel(x, y + 1, z);
	n -= game.volumeData->getVoxelRel(x, y - 1, z);
	n -= game.volumeData->getVoxelRel(x, y, z + 1);
	n -= game.volumeData->getVoxelRel(x, y, z - 1);
	n += maxVal * 4;
	n = std::max(0.0f, n);
	n /= (float)(maxVal * 6);

	int data = game.volumeData->getVoxelRel(x, y, z);
	data = std::max(minVal, (int)(data + v * n * minVal));
	game.volumeData->setVoxelRel(x, y, z, data);*/
}

void Game::editLevel_Smooth(bool leftMB, Vector3 pos, Vector3 dir, int funcNumber)
{
	Vector3 hit;

	if (leftMB)
	{
		// Build
		if (game.volumeData->getRayIntersectionEx(pos, dir, &hit, 400))
		{
			if (!game.mPlayer || ((hit - pos).length() > game.brushSize + 3))
			{
				Game::editLevel_CallShapeFunc(funcNumber, hit, game.brushSize, &Game::editLevel_Smooth_CB_Add);
				lastEditPos = hit;
			}
		}
	}
	else
	{
		// Remove
		if (game.volumeData->getRayIntersectionEx(pos, dir, &hit, 400))
		{
			Game::editLevel_CallShapeFunc(funcNumber, hit, game.brushSize, &Game::editLevel_Smooth_CB_Sub);
			lastEditPos = hit;
		}
	}
}

void Game::editLevel_Smooth2_CB_Add(int x, int y, int z, float v)
{
	const int maxVal = std::numeric_limits<signed char>::max();

	// gather sum of neighbours
	float n = 0;
	for (int dx = -1; dx < 2; dx++)
		for (int dy = -1; dy < 2; dy++)
			for (int dz = -1; dz < 2; dz++)
				if (x != 0 || y != 0 || z != 0)
					n += (game.volumeData->getVoxelRel(x + dx, y + dy, z + dz) > -30) ? 1 : 0;

	if (n > 0)
	{
		int data = game.volumeData->getVoxelRel(x, y, z);
		data = std::min(maxVal, (int)(data + (v / (2 * game.brushSize)) * (n / 3.0f) * maxVal));
		game.volumeData->setVoxelRel(x, y, z, data);
	}
}

void Game::editLevel_Smooth2_CB_Sub(int x, int y, int z, float v)
{
	const int minVal = std::numeric_limits<signed char>::min();

	// gather sum of neighbours
	float n = 0;
	for (int dx = -1; dx < 2; dx++)
		for (int dy = -1; dy < 2; dy++)
			for (int dz = -1; dz < 2; dz++)
				if (x != 0 || y != 0 || z != 0)
					n += (game.volumeData->getVoxelRel(x + dx, y + dy, z + dz) < 30) ? 1 : 0;

	if (n > 0)
	{
		int data = game.volumeData->getVoxelRel(x, y, z);
		data = std::max(minVal, (int)(data + (v / (2 * game.brushSize)) * (n / 3.0f) * minVal));
		game.volumeData->setVoxelRel(x, y, z, data);
	}
}

void Game::editLevel_Smooth2(bool leftMB, Vector3 pos, Vector3 dir, int funcNumber)
{
	Vector3 hit;

	if (leftMB)
	{
		// Build
		if (game.volumeData->getRayIntersectionEx(pos, dir, &hit, 400))
		{
			if (!game.mPlayer || ((hit - pos).length() > game.brushSize + 3))
			{
				Game::editLevel_CallShapeFunc(funcNumber, hit, game.brushSize, &Game::editLevel_Smooth2_CB_Add);
				lastEditPos = hit;
			}
		}
	}
	else
	{
		// Remove
		if (game.volumeData->getRayIntersectionEx(pos, dir, &hit, 400))
		{
			Game::editLevel_CallShapeFunc(funcNumber, hit, game.brushSize, &Game::editLevel_Smooth2_CB_Sub);
			lastEditPos = hit;
		}
	}
}

void Game::editLevel_Average_CB(int x, int y, int z, float v)
{
	const int maxVal = std::numeric_limits<signed char>::max();
	const int minVal = std::numeric_limits<signed char>::min();

	// gather sum of 3x3 voxel block - OLD, CUBIC
	/*float n = 0;
	for (int dx = -1; dx < 2; dx++)
		for (int dy = -1; dy < 2; dy++)
			for (int dz = -1; dz < 2; dz++)
				n += game.volumeData->getVoxelRel(x + dx, y + dy, z + dz);
	n /= 9;*/

	// gather sum of voxel sphere - NEW, SPHERICAL
	float n = 0;
	n += game.volumeData->getVoxelRel(x + 1, y + 0, z + 0);
	n += game.volumeData->getVoxelRel(x - 1, y + 0, z + 0);
	n += game.volumeData->getVoxelRel(x + 0, y + 1, z + 0);
	n += game.volumeData->getVoxelRel(x + 0, y - 1, z + 0);
	n += game.volumeData->getVoxelRel(x + 0, y + 0, z + 1);
	n += game.volumeData->getVoxelRel(x + 0, y + 0, z - 1);
	n += game.volumeData->getVoxelRel(x + 0, y + 0, z + 0);

	const float cornerFactor = 1 / sqrtf(3.0f);
	n += game.volumeData->getVoxelRel(x + 1, y + 1, z + 1) * cornerFactor;
	n += game.volumeData->getVoxelRel(x - 1, y + 1, z + 1) * cornerFactor;
	n += game.volumeData->getVoxelRel(x + 1, y - 1, z + 1) * cornerFactor;
	n += game.volumeData->getVoxelRel(x + 1, y + 1, z - 1) * cornerFactor;
	n += game.volumeData->getVoxelRel(x - 1, y - 1, z + 1) * cornerFactor;
	n += game.volumeData->getVoxelRel(x + 1, y - 1, z - 1) * cornerFactor;
	n += game.volumeData->getVoxelRel(x - 1, y + 1, z - 1) * cornerFactor;
	n += game.volumeData->getVoxelRel(x - 1, y - 1, z - 1) * cornerFactor;

	const float edgeFactor = 1 / sqrtf(2.0f);
	n += game.volumeData->getVoxelRel(x + 1, y + 1, z + 0) * edgeFactor;
	n += game.volumeData->getVoxelRel(x + 0, y + 1, z + 1) * edgeFactor;
	n += game.volumeData->getVoxelRel(x + 1, y + 0, z + 1) * edgeFactor;

	n += game.volumeData->getVoxelRel(x - 1, y + 1, z + 0) * edgeFactor;
	n += game.volumeData->getVoxelRel(x + 0, y - 1, z + 1) * edgeFactor;
	n += game.volumeData->getVoxelRel(x - 1, y + 0, z + 1) * edgeFactor;

	n += game.volumeData->getVoxelRel(x + 1, y - 1, z + 0) * edgeFactor;
	n += game.volumeData->getVoxelRel(x + 0, y + 1, z - 1) * edgeFactor;
	n += game.volumeData->getVoxelRel(x + 1, y + 0, z - 1) * edgeFactor;

	n += game.volumeData->getVoxelRel(x - 1, y - 1, z + 0) * edgeFactor;
	n += game.volumeData->getVoxelRel(x + 0, y - 1, z - 1) * edgeFactor;
	n += game.volumeData->getVoxelRel(x - 1, y + 0, z - 1) * edgeFactor;

	n /= (7 + 8 * cornerFactor + 12 * edgeFactor) * 0.8f;	// 0.8f: otherwise, voxels often get the value 0 -> angled geometry!

	//n += 40;	// use this if you want to create a further smooth dig mode

	v = std::min(1.0f, v);
	int data = game.volumeData->getVoxelRel(x, y, z);
	data = std::max(minVal, (int)(data + (n - data) * 0.3f * v));
	data = std::min(maxVal, (int)(data));
	game.volumeData->setVoxelRel(x, y, z, data);
}

void Game::editLevel_Average(bool leftMB, Vector3 pos, Vector3 dir, int funcNumber)
{
	Vector3 hit;

	if (game.volumeData->getRayIntersectionEx(pos, dir, &hit, 400))
	{
		Game::editLevel_CallShapeFunc(funcNumber, hit, game.brushSize, &Game::editLevel_Average_CB);
		lastEditPos = hit;
	}
}

void Game::editLevel_Texturize_CB(int x, int y, int z, float v)
{
	if (v >= 0.2f)
	{
		int n = 0;
		for (int dx = -1; dx < 2; dx++)
			for (int dy = -1; dy < 2; dy++)
				for (int dz = -1; dz < 2; dz++)
					if (x != 0 || y != 0 || z != 0)
						n += (game.volumeData->getVoxelRel(x + dx, y + dy, z + dz) > 0) ? 1 : 0;

		if (n > 0)
			game.volumeData->setTextureRel(x, y, z, game.brushTexture);
	}
}

void Game::editLevel_Texturize(bool leftMB, Vector3 pos, Vector3 dir, int funcNumber)
{
	Vector3 hit;
	if (game.volumeData->getRayIntersectionEx(pos, dir, &hit, 400))
	{
		Game::editLevel_CallShapeFunc(funcNumber, hit, game.brushSize, &Game::editLevel_Texturize_CB);
		lastEditPos = hit;
	}
}

void Game::editLevel_TexturizeSurface_CB(int x, int y, int z, float v)
{
	if (v >= 0.2f)
	{
		int n = 0, nrock = 0;
		for (int dx = -1; dx < 2; dx++)
			for (int dy = -1; dy < 2; dy++)
				for (int dz = -1; dz < 2; dz++)
					if (x != 0 || y != 0 || z != 0)
					{
						n += (game.volumeData->getVoxelRel(x + dx, y + dy, z + dz) < 0) ? 1 : 0;
						nrock += (game.volumeData->getVoxelRel(x + dx, y + dy, z + dz) > 0) ? 1 : 0;
					}

		if (n > 0 && nrock > 0)
			game.volumeData->setTextureRel(x, y, z, game.brushTexture);
	}
}

void Game::editLevel_TexturizeSurface(bool leftMB, Vector3 pos, Vector3 dir, int funcNumber)
{
	Vector3 hit;
	if (game.volumeData->getRayIntersectionEx(pos, dir, &hit, 400))
	{
		Game::editLevel_CallShapeFunc(funcNumber, hit, game.brushSize, &Game::editLevel_TexturizeSurface_CB);
		lastEditPos = hit;
	}
}

void Game::editLevel_FloatingRockReduction_CB(int x, int y, int z, float v)
{
	if (v >= 0.1f)
	{
		if (game.volumeData->getVoxelRel(x, y, z) < -1)
			return;

		int n = 0;
		for (int dx = -1; dx < 2; dx++)
			for (int dy = -1; dy < 2; dy++)
				for (int dz = -1; dz < 2; dz++)
				{
					//n += game.volumeData->getVoxelRel(x + dx, y + dy, z + dz);
					n += (game.volumeData->getVoxelRel(x + dx, y + dy, z + dz) > 0) ? 1 : 0;
				}

		if (n < 9) //(27 * -128) + 128 * 9)
			game.volumeData->setVoxelRel(x, y, z, -128);
	}
}

void Game::editLevel_CallShapeFunc(int shapeNr, Vector3 pos, Real radius, void (*voxelFunc)(int,int,int,float))
{
	switch (shapeNr)
	{
	case 0:	game.volumeData->execSphereFunc(pos, radius, voxelFunc);	break;
	case 1:	game.volumeData->execCubeFunc(pos, radius, voxelFunc);		break;
	}
}

void Game::editLevel(bool leftMB, Vector3 pos, Vector3 dir)
{
	lastEditPos = Vector3(-1, -1, -1);

	// Get options
	CEGUI::Listbox* box = (CEGUI::Listbox*)CEGUI::WindowManager::getSingleton().getWindow("BrushShapeEdit");
	CEGUI::ListboxItem* item = box->getFirstSelectedItem();
	if (!item)
		return;
	uint64_t shapeNumber = (uint64_t)item->getUserData(); // 64bit safe

	box = (CEGUI::Listbox*)CEGUI::WindowManager::getSingleton().getWindow("BrushOpEdit");
	item = box->getFirstSelectedItem();
	if (!item)
		return;

	// Execute command
	void (*func)(bool,Vector3,Vector3,int) = (void (*)(bool, Vector3, Vector3, int))item->getUserData();
	func(leftMB, pos, dir, shapeNumber);

	// Apply "Post-Processing effects" like floating rock reduction or auto-texturing
	float postProcessRadius = game.brushSize;

	// Floating rock reduction
	CEGUI::Checkbox* chk = (CEGUI::Checkbox*)CEGUI::WindowManager::getSingleton().getWindow("FloatingRockReduction");
	if (chk->isSelected())
	{
		postProcessRadius += 3;
		for (int i = 0; i < 3; i++)
			Game::editLevel_CallShapeFunc(shapeNumber, lastEditPos, postProcessRadius, &Game::editLevel_FloatingRockReduction_CB);
	}

	// Auto-texturing
	lastEditPos /= game.volumeData->scale;
	postProcessRadius /= game.volumeData->scale;
	postProcessRadius++;
	chk = (CEGUI::Checkbox*)CEGUI::WindowManager::getSingleton().getWindow("AutoTexturize");
	if (chk->isSelected())
		Level::other_ApplyTextures(lastEditPos.x - postProcessRadius, lastEditPos.y - postProcessRadius, lastEditPos.z - postProcessRadius, lastEditPos.x + postProcessRadius, lastEditPos.y + postProcessRadius, lastEditPos.z + postProcessRadius);
	// TODO: sometimes vertices of by autotex changed regions are not regenerated. Use brush size 2 and paint at block boundaries to check
}

bool Game::spawnObject(const CEGUI::EventArgs &args)
{
	// Retrieve the name of the object to create
	CEGUI::Listbox* box = (CEGUI::Listbox*)CEGUI::WindowManager::getSingleton().getWindow("SpawnObjectEdit");
	CEGUI::ListboxItem* item = box->getFirstSelectedItem();
	if (!item)
		return true;
	CEGUI::String name = item->getText();

	// Create the object
	Object* obj = objectManager.createObject(name.c_str(), INVALID_OBJECT_ID);
	if (!obj)
	{
		LogManager::getSingleton().logMessage(("ERROR: failed to create object of type " + name + " !").c_str(), LML_CRITICAL);
		return true;	// failed to create the object
	}
	Vector3 position = Vector3(camera->getDerivedPosition() + camera->getDerivedDirection() * 8);
	obj->position = position;
	obj->sendMessage(COMPMSG_CREATE, (void*)(&position));

	return true;
}
bool Game::deleteObject(const CEGUI::EventArgs &args)
{
	Object* selObject = objectManager.getSelectedObject();
	if (!selObject)
		return true;
	
	objectManager.deleteObject(selObject);
	
	return true;
}
bool Game::toggleRunSimulation(const CEGUI::EventArgs &args)
{
	const CEGUI::WindowEventArgs& wndArgs = (const CEGUI::WindowEventArgs&)args;
	CEGUI::Checkbox* chk = (CEGUI::Checkbox*)wndArgs.window;
	runSimulation = chk->isSelected();
	return true;
}

bool Game::toggleAutomaticPaging(const CEGUI::EventArgs &args)
{
	const CEGUI::WindowEventArgs& wndArgs = (const CEGUI::WindowEventArgs&)args;
	CEGUI::Checkbox* chk = (CEGUI::Checkbox*)wndArgs.window;
	volumeData->automaticPaging = chk->isSelected();
	return true;
}
bool Game::togglePagingMode(const CEGUI::EventArgs &args)
{
	CEGUI::RadioButton* radio = (CEGUI::RadioButton*)CEGUI::WindowManager::getSingleton().getWindow("PagingModeOpen");
	if (radio->isSelected())
		volumeData->pagingMode = PAGINGMODE_OPEN;
	else
		volumeData->pagingMode = PAGINGMODE_CLOSED;
	return true;
}

bool Game::saveVoxelData(const CEGUI::EventArgs &args)
{
	gameDataStorage.saveModifiedBlocks(savePath.c_str(), volumeData);
	return true;
}
bool Game::loadVoxelData(const CEGUI::EventArgs &args)
{
	volumeData->reset();
	gameDataStorage.clear();
	gameDataStorage.loadBlocks(savePath.c_str(), volumeData);
	return true;
}
bool Game::saveObjectData(const CEGUI::EventArgs &args)
{
	gameDataStorage.saveObjects(savePath.c_str());
	return true;
}
bool Game::loadObjectData(const CEGUI::EventArgs &args)
{
	gameDataStorage.loadObjects(savePath.c_str());
	return true;
}
bool Game::loadAllData(const CEGUI::EventArgs &args)
{
	volumeData->reset();
	gameDataStorage.clear();
	gameDataStorage.loadBlocks(savePath.c_str(), volumeData);
	gameDataStorage.loadObjects(savePath.c_str());
	return true;
}

bool Game::activateGUIInputMode(const CEGUI::EventArgs &args)
{
	gameInputHandler.guiInputMode = true;
	return true;
}
bool Game::deactivateGUIInputMode(const CEGUI::EventArgs &args)
{
	gameInputHandler.guiInputMode = false;
	finishedGUIInput(args);
	return true;
}
bool Game::deactivateGUIInputModeWithEnter(const CEGUI::EventArgs &args)
{
	CEGUI::KeyEventArgs& keyArgs = (CEGUI::KeyEventArgs&)args;

	if (keyArgs.scancode == CEGUI::Key::Return)
	{
		keyArgs.window->deactivate();
		return deactivateGUIInputMode(args);
	}

	return true;
}

bool Game::gameStart_ChatKeyDown(const CEGUI::EventArgs &args)
{
	#ifndef DIGISPE
	CEGUI::KeyEventArgs& keyArgs = (CEGUI::KeyEventArgs&)args;
	
	if (keyArgs.scancode == CEGUI::Key::Return)
	{
		CEGUI::Editbox* chatBox = (CEGUI::Editbox*)CEGUI::WindowManager::getSingleton().getWindow("GameStartChat");
		network->sendChatMessage(chatBox->getText().c_str());
		chatBox->setText("");
	}
	#endif
	
	return true;
}

void Game::finishedGUIInput(const CEGUI::EventArgs &args)
{
	CEGUI::WindowEventArgs& wndArgs = (CEGUI::WindowEventArgs&)args;
	CEGUI::Window* wnd = wndArgs.window;

	if (wnd == CEGUI::WindowManager::getSingleton().getWindow("BrushSizeEdit"))
	{
		brushSize = StringConverter::parseReal(CEGUI::WindowManager::getSingleton().getWindow("BrushSizeEdit")->getText().c_str());
		setNewBrushSize();
	}
	else if (wnd == CEGUI::WindowManager::getSingleton().getWindow("BrushTextureEdit"))
	{
		brushTexture = StringConverter::parseReal(CEGUI::WindowManager::getSingleton().getWindow("BrushTextureEdit")->getText().c_str());
		setNewBrushTexture();
	}
	else if (wnd == CEGUI::WindowManager::getSingleton().getWindow("VolumeScaleEdit"))
	{
		volumeData->scale = StringConverter::parseReal(CEGUI::WindowManager::getSingleton().getWindow("VolumeScaleEdit")->getText().c_str());
		setNewVolumeScale();
	}
	else if ((wnd == CEGUI::WindowManager::getSingleton().getWindow("AutotexTopEdit")) ||
				 (wnd == CEGUI::WindowManager::getSingleton().getWindow("AutotexSideEdit")) ||
				 (wnd == CEGUI::WindowManager::getSingleton().getWindow("AutotexInner1Edit")) ||
				 (wnd == CEGUI::WindowManager::getSingleton().getWindow("AutotexInner2Edit")))
	{
		autotexTop = StringConverter::parseInt(CEGUI::WindowManager::getSingleton().getWindow("AutotexTopEdit")->getText().c_str());
		autotexSide = StringConverter::parseInt(CEGUI::WindowManager::getSingleton().getWindow("AutotexSideEdit")->getText().c_str());
		autotexInner1 = StringConverter::parseInt(CEGUI::WindowManager::getSingleton().getWindow("AutotexInner1Edit")->getText().c_str());
		autotexInner2 = StringConverter::parseInt(CEGUI::WindowManager::getSingleton().getWindow("AutotexInner2Edit")->getText().c_str());
	}
}

bool Game::moveWindowPX(const CEGUI::EventArgs &args)
{
	volumeData->moveWindow(volumeData->windowXInBlocks + 1, volumeData->windowYInBlocks, volumeData->windowZInBlocks);
	return true;
}
bool Game::moveWindowMX(const CEGUI::EventArgs &args)
{
	volumeData->moveWindow(volumeData->windowXInBlocks - 1, volumeData->windowYInBlocks, volumeData->windowZInBlocks);
	return true;
}
bool Game::moveWindowPY(const CEGUI::EventArgs &args)
{
	volumeData->moveWindow(volumeData->windowXInBlocks, volumeData->windowYInBlocks + 1, volumeData->windowZInBlocks);
	return true;
}
bool Game::moveWindowMY(const CEGUI::EventArgs &args)
{
	volumeData->moveWindow(volumeData->windowXInBlocks, volumeData->windowYInBlocks - 1, volumeData->windowZInBlocks);
	return true;
}
bool Game::moveWindowPZ(const CEGUI::EventArgs &args)
{
	volumeData->moveWindow(volumeData->windowXInBlocks, volumeData->windowYInBlocks, volumeData->windowZInBlocks + 1);
	return true;
}
bool Game::moveWindowMZ(const CEGUI::EventArgs &args)
{
	volumeData->moveWindow(volumeData->windowXInBlocks, volumeData->windowYInBlocks, volumeData->windowZInBlocks - 1);
	return true;
}

void Game::newGame()
{
	// TODO: Execute a script instead!
	aiFactionManager = new AIFactionManager();

	aiFactionManager->addFaction("Player", AIATTITUDE_FRIENDLY);
	aiFactionManager->addFaction("GovernmentMachines", AIATTITUDE_FRIENDLY);
	aiFactionManager->addFaction("RebelMachines", AIATTITUDE_FRIENDLY);
	aiFactionManager->addFaction("Animals", AIATTITUDE_FRIENDLY);
	aiFactionManager->addFaction("AlwaysHostile", AIATTITUDE_HOSTILE);

	aiFactionManager->setAttitude("Player", "GovernmentMachines", AIATTITUDE_HOSTILE);
	aiFactionManager->setAttitude("Player", "RebelMachines", AIATTITUDE_FRIENDLY);
	aiFactionManager->setAttitude("Player", "Animals", AIATTITUDE_HOSTILE);
	aiFactionManager->setAttitude("Player", "AlwaysHostile", AIATTITUDE_HOSTILE);

	aiFactionManager->setAttitude("GovernmentMachines", "RebelMachines", AIATTITUDE_HOSTILE);
	aiFactionManager->setAttitude("GovernmentMachines", "Animals", AIATTITUDE_HOSTILE);
	aiFactionManager->setAttitude("GovernmentMachines", "AlwaysHostile", AIATTITUDE_HOSTILE);

	aiFactionManager->setAttitude("RebelMachines", "Animals", AIATTITUDE_HOSTILE);
	aiFactionManager->setAttitude("RebelMachines", "AlwaysHostile", AIATTITUDE_HOSTILE);
}

void Game::endGame()
{
	// TODO: aiFactionManager.saveToFile(...) ?
	delete aiFactionManager;

	// TODO: save to file
	gameDataStorage.clear();
}

void Game::addMessage(const std::string& msg, EMessageType type)
{
	if (messages.size() == MAX_STORED_MESSAGES)
	{
		messages.pop_front();
		messageTypes.pop_front();
	}
	messages.push_back(msg);
	messageTypes.push_back(type);
	
	++numNewMessagesThisFrame;
	if (numNewMessagesThisFrame > MAX_STORED_MESSAGES)
		numNewMessagesThisFrame = MAX_STORED_MESSAGES;
}
void Game::clearMessages()
{
	messages.clear();
	messageTypes.clear();
	numNewMessagesThisFrame = 0;
}
const std::string& Game::getNthLatestMessage(int n)
{
	return messages.at(messages.size() - 1 - n);
}
void Game::messagesUpdated()
{
	numNewMessagesThisFrame = 0;
}
